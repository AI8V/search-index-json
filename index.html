<!DOCTYPE html>
<html lang="ar" dir="rtl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ŸÖŸàŸÑÿØ ŸÅŸáÿ±ÿ≥ ÿßŸÑÿ®ÿ≠ÿ´ ÿßŸÑŸÖÿ™ÿ∑Ÿàÿ± - Ultimate Edition</title>
    <link href="https://cdnjs.cloudflare.com/ajax/libs/bootstrap/5.3.0/css/bootstrap.min.css" rel="stylesheet">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
    <style>
        :root {
            --bg-primary: #ffffff;
            --bg-secondary: #f8f9fa;
            --text-primary: #212529;
            --text-secondary: #6c757d;
            --border-color: #dee2e6;
            --card-bg: #ffffff;
            --input-bg: #ffffff;
            --accent-color: #0d6efd;
        }

        [data-theme="dark"] {
            --bg-primary: #1a1a1a;
            --bg-secondary: #2d2d2d;
            --text-primary: #ffffff;
            --text-secondary: #b0b0b0;
            --border-color: #404040;
            --card-bg: #2d2d2d;
            --input-bg: #3d3d3d;
            --accent-color: #4dabf7;
        }

        body {
            background-color: var(--bg-primary);
            color: var(--text-primary);
            transition: all 0.3s ease;
        }

        .card {
            background-color: var(--card-bg);
            border-color: var(--border-color);
        }

        .form-control, .form-select {
            background-color: var(--input-bg);
            border-color: var(--border-color);
            color: var(--text-primary);
        }

        .form-control:focus, .form-select:focus {
            background-color: var(--input-bg);
            border-color: var(--accent-color);
            color: var(--text-primary);
        }

        .result-box {
            background: var(--bg-secondary);
            border: 1px solid var(--border-color);
            border-radius: 8px;
            padding: 20px;
            margin: 20px 0;
            max-height: 500px;
            overflow-y: auto;
        }
        
        .page-item {
            border: 1px solid var(--border-color);
            border-radius: 6px;
            padding: 15px;
            margin: 10px 0;
            background: var(--card-bg);
            position: relative;
            transition: all 0.3s ease;
        }

        .page-item:hover {
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
        }
        
        .page-title {
            color: var(--accent-color);
            font-weight: bold;
            margin-bottom: 5px;
        }
        
        .page-url {
            color: var(--text-secondary);
            font-size: 0.9em;
        }
        
        .file-drop-zone {
            border: 2px dashed var(--border-color);
            border-radius: 8px;
            padding: 30px;
            text-align: center;
            margin: 15px 0;
            transition: all 0.3s ease;
            cursor: pointer;
            background: var(--bg-secondary);
        }
        
        .file-drop-zone:hover {
            border-color: var(--accent-color);
            background-color: rgba(13, 110, 253, 0.1);
        }
        
        .file-drop-zone.dragover {
            border-color: var(--accent-color);
            background-color: rgba(13, 110, 253, 0.2);
        }

        .url-textarea-container {
            position: relative;
        }

        .url-textarea-drop {
            border: 2px dashed transparent;
            transition: all 0.3s ease;
        }

        .url-textarea-drop.dragover {
            border-color: #28a745;
            background-color: rgba(40, 167, 69, 0.1);
        }
        
        .progress-container {
            display: none;
            margin: 15px 0;
        }
        
        .feature-badge {
            background: linear-gradient(45deg, #28a745, #20c997);
            color: white;
            padding: 2px 8px;
            border-radius: 12px;
            font-size: 0.8em;
            margin-left: 5px;
        }

        .pro-badge {
            background: linear-gradient(45deg, #6f42c1, #e83e8c);
            color: white;
            padding: 2px 8px;
            border-radius: 12px;
            font-size: 0.8em;
            margin-left: 5px;
        }

        .ultimate-badge {
            background: linear-gradient(45deg, #fd7e14, #dc3545);
            color: white;
            padding: 2px 8px;
            border-radius: 12px;
            font-size: 0.8em;
            margin-left: 5px;
            animation: pulse 2s infinite;
        }

        @keyframes pulse {
            0% { transform: scale(1); }
            50% { transform: scale(1.05); }
            100% { transform: scale(1); }
        }
        
        .edit-btn {
            position: absolute;
            top: 10px;
            left: 10px;
            padding: 2px 6px;
            font-size: 0.7em;
        }
        
        .editable-content {
            border: 1px dashed #ccc;
            padding: 5px;
            border-radius: 4px;
            cursor: text;
        }
        
        .editable-content:focus {
            outline: 2px solid var(--accent-color);
            background-color: var(--input-bg);
        }
        
        .sitemap-section {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border-radius: 8px;
            padding: 20px;
            margin: 15px 0;
        }
        
        .robots-section {
            background: linear-gradient(135deg, #ff9a9e 0%, #fecfef 100%);
            color: #333;
            border-radius: 8px;
            padding: 20px;
            margin: 15px 0;
        }

        .manifest-section {
            background: linear-gradient(135deg, #a8edea 0%, #fed6e3 100%);
            color: #333;
            border-radius: 8px;
            padding: 20px;
            margin: 15px 0;
        }

        .github-section {
            background: linear-gradient(135deg, #d299c2 0%, #fef9d7 100%);
            color: #333;
            border-radius: 8px;
            padding: 20px;
            margin: 15px 0;
        }
        
        .drop-zone {
            border: 2px dashed rgba(255,255,255,0.5);
            border-radius: 8px;
            padding: 20px;
            text-align: center;
            cursor: pointer;
            transition: all 0.3s ease;
        }
        
        .drop-zone:hover {
            border-color: white;
            background-color: rgba(255,255,255,0.1);
        }

        .dark-mode-toggle {
            position: fixed;
            top: 20px;
            left: 20px;
            z-index: 1000;
            border-radius: 50px;
            padding: 8px 16px;
            border: none;
            background: linear-gradient(45deg, #667eea, #764ba2);
            color: white;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .dark-mode-toggle:hover {
            transform: scale(1.05);
            box-shadow: 0 4px 15px rgba(0,0,0,0.2);
        }

        .export-buttons {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
            margin-top: 15px;
        }

        .export-buttons .btn {
            flex: 1;
            min-width: 120px;
        }

        .copy-options {
            display: none;
            margin-top: 10px;
            padding: 15px;
            background: var(--bg-secondary);
            border-radius: 8px;
            border: 1px solid var(--border-color);
        }

        .zip-progress {
            display: none;
            margin-top: 10px;
        }

        .stats-panel {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border-radius: 8px;
            padding: 20px;
            margin: 15px 0;
        }

        .stat-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 8px 0;
            border-bottom: 1px solid rgba(255,255,255,0.2);
        }

        .stat-item:last-child {
            border-bottom: none;
        }

        .live-counter {
            position: fixed;
            top: 80px;
            left: 20px;
            z-index: 999;
            background: linear-gradient(45deg, #28a745, #20c997);
            color: white;
            padding: 8px 16px;
            border-radius: 20px;
            font-weight: bold;
            box-shadow: 0 2px 10px rgba(0,0,0,0.2);
            transition: all 0.3s ease;
        }

        .filter-section {
            background: var(--bg-secondary);
            border: 1px solid var(--border-color);
            border-radius: 8px;
            padding: 15px;
            margin: 15px 0;
        }

        .hidden {
            display: none !important;
        }

        @media (max-width: 768px) {
            .export-buttons {
                flex-direction: column;
            }
            
            .export-buttons .btn {
                width: 100%;
                margin-bottom: 5px;
            }

            .live-counter {
                position: relative;
                top: auto;
                left: auto;
                margin: 10px 0;
                display: inline-block;
            }
        }
    </style>
</head>
<body>
    <button class="dark-mode-toggle" onclick="toggleDarkMode()">
        üåô ÿßŸÑŸàÿ∂ÿπ ÿßŸÑŸÑŸäŸÑŸä
    </button>

    <div class="live-counter" id="liveCounter" style="display: none;">
        üìä ÿßŸÑÿπŸÜÿßÿµÿ±: <span id="counterValue">0</span>
    </div>

    <div class="container mt-5">
        <h1 class="text-center mb-5">üîç ŸÖŸàŸÑÿØ ŸÅŸáÿ±ÿ≥ ÿßŸÑÿ®ÿ≠ÿ´ ÿßŸÑŸÖÿ™ÿ∑Ÿàÿ± <span class="ultimate-badge">Ultimate</span></h1>
        
        <div class="row">
            <div class="col-md-6">
                <div class="card">
                    <div class="card-header">
                        <h3>üìù ÿ•ÿØÿÆÿßŸÑ ÿµŸÅÿ≠ÿßÿ™ ÿßŸÑŸÖŸàŸÇÿπ</h3>
                    </div>
                    <div class="card-body">
                        <!-- GitHub Pages Section -->
                        <div class="github-section">
                            <h5>üêô ÿßÿ≥ÿ™Ÿäÿ±ÿßÿØ ŸÖŸÜ GitHub Pages <span class="feature-badge">ÿ¨ÿØŸäÿØ</span></h5>
                            <div class="row">
                                <div class="col-8">
                                    <input type="url" class="form-control" id="githubUrl" placeholder="https://username.github.io/repository">
                                </div>
                                <div class="col-4">
                                    <button class="btn btn-outline-dark w-100" onclick="fetchFromGitHub()">
                                        üöÄ ÿ¨ŸÑÿ®
                                    </button>
                                </div>
                            </div>
                            <small class="d-block mt-2">ÿ≥Ÿäÿ™ŸÖ ÿ¨ŸÑÿ® Ÿàÿ™ÿ≠ŸÑŸäŸÑ ÿ¨ŸÖŸäÿπ ÿµŸÅÿ≠ÿßÿ™ HTML ŸÖŸÜ ÿßŸÑŸÖŸàŸÇÿπ ÿ™ŸÑŸÇÿßÿ¶ŸäÿßŸã</small>
                        </div>

                        <!-- Robots.txt Section -->
                        <div class="robots-section">
                            <h5>ü§ñ ÿßÿ≥ÿ™Ÿäÿ±ÿßÿØ ŸÖŸÜ robots.txt <span class="feature-badge">ÿ¨ÿØŸäÿØ</span></h5>
                            <div class="drop-zone" id="robotsDropZone">
                                <i class="fas fa-robot fa-2x mb-2"></i>
                                <p class="mb-2">ÿßÿ≥ÿ≠ÿ® Ÿàÿ£ŸÅŸÑÿ™ ŸÖŸÑŸÅ robots.txt ŸáŸÜÿß ÿ£Ÿà ÿßŸÜŸÇÿ± ŸÑŸÑÿßÿÆÿ™Ÿäÿßÿ±</p>
                                <small>ÿ≥Ÿäÿ™ŸÖ ÿßÿ≥ÿ™ÿÆÿ±ÿßÿ¨ ÿßŸÑÿµŸÅÿ≠ÿßÿ™ ÿßŸÑŸÖÿ≥ÿ™ÿ®ÿπÿØÿ© ŸàÿßŸÑŸÖÿ≥ŸÖŸàÿ≠ÿ©</small>
                                <input type="file" id="robotsFileInput" accept=".txt" style="display: none;">
                            </div>
                        </div>

                        <!-- Manifest.json Section -->
                        <div class="manifest-section">
                            <h5>üì± ÿßÿ≥ÿ™Ÿäÿ±ÿßÿØ ŸÖŸÜ manifest.json <span class="feature-badge">PWA</span></h5>
                            <div class="drop-zone" id="manifestDropZone">
                                <i class="fas fa-mobile-alt fa-2x mb-2"></i>
                                <p class="mb-2">ÿßÿ≥ÿ≠ÿ® Ÿàÿ£ŸÅŸÑÿ™ ŸÖŸÑŸÅ manifest.json ŸáŸÜÿß ÿ£Ÿà ÿßŸÜŸÇÿ± ŸÑŸÑÿßÿÆÿ™Ÿäÿßÿ±</p>
                                <small>ÿ≥Ÿäÿ™ŸÖ ÿßÿ≥ÿ™ÿÆÿ±ÿßÿ¨ ÿ£ÿ≥ŸÖÿßÿ° ÿßŸÑÿ£ŸÇÿ≥ÿßŸÖ ŸÖŸÜ ÿ™ÿ∑ÿ®ŸäŸÇ PWA</small>
                                <input type="file" id="manifestFileInput" accept=".json" style="display: none;">
                            </div>
                        </div>

                        <!-- Sitemap.xml Section -->
                        <div class="sitemap-section">
                            <h5>üó∫Ô∏è ÿßÿ≥ÿ™Ÿäÿ±ÿßÿØ ŸÖŸÜ Sitemap.xml <span class="feature-badge">ÿ∞ŸÉŸä</span></h5>
                            <div class="drop-zone" id="sitemapDropZone">
                                <i class="fas fa-sitemap fa-2x mb-2"></i>
                                <p class="mb-2">ÿßÿ≥ÿ≠ÿ® Ÿàÿ£ŸÅŸÑÿ™ ŸÖŸÑŸÅ sitemap.xml ŸáŸÜÿß ÿ£Ÿà ÿßŸÜŸÇÿ± ŸÑŸÑÿßÿÆÿ™Ÿäÿßÿ±</p>
                                <small>ÿ≥Ÿäÿ™ŸÖ ÿßÿ≥ÿ™ÿÆÿ±ÿßÿ¨ ÿ¨ŸÖŸäÿπ ÿßŸÑÿ±Ÿàÿßÿ®ÿ∑ ÿ™ŸÑŸÇÿßÿ¶ŸäÿßŸã ŸÖŸÜ ÿÆÿ±Ÿäÿ∑ÿ© ÿßŸÑŸÖŸàŸÇÿπ</small>
                                <input type="file" id="sitemapFileInput" accept=".xml" style="display: none;">
                            </div>
                        </div>

                        <!-- HTML File Analysis Section -->
                        <div class="mb-4">
                            <label class="form-label">
                                üìÑ ÿ™ÿ≠ŸÑŸäŸÑ ŸÖŸÑŸÅÿßÿ™ HTML ÿ™ŸÑŸÇÿßÿ¶ŸäŸãÿß <span class="feature-badge">ŸÖÿ≠ÿ≥ŸÜ</span>
                            </label>
                            <div class="file-drop-zone" id="fileDropZone">
                                <i class="fas fa-cloud-upload-alt fa-2x text-muted mb-2"></i>
                                <p class="mb-2">ÿßÿ≥ÿ≠ÿ® Ÿàÿ£ŸÅŸÑÿ™ ŸÖŸÑŸÅÿßÿ™ HTML ŸáŸÜÿß ÿ£Ÿà ÿßŸÜŸÇÿ± ŸÑŸÑÿßÿÆÿ™Ÿäÿßÿ±</p>
                                <small class="text-muted">ÿ≥Ÿäÿ™ŸÖ ÿßÿ≥ÿ™ÿÆÿ±ÿßÿ¨ ÿßŸÑÿπŸÜŸàÿßŸÜ ŸàÿßŸÑŸàÿµŸÅ ÿ™ŸÑŸÇÿßÿ¶ŸäŸãÿß ŸÖŸÜ ŸÉŸÑ ŸÖŸÑŸÅ</small>
                                <input type="file" id="htmlFileInput" multiple accept=".html,.htm" style="display: none;">
                            </div>
                            <div class="progress-container" id="progressContainer">
                                <div class="progress">
                                    <div class="progress-bar" id="progressBar" role="progressbar" style="width: 0%"></div>
                                </div>
                                <small class="text-muted" id="progressText">ÿ¨ÿßÿ±Ÿä ÿßŸÑŸÖÿπÿßŸÑÿ¨ÿ©...</small>
                            </div>
                        </div>

                        <!-- Bulk Import Section -->
                        <div class="mb-4">
                            <label class="form-label">
                                üìÇ ÿßÿ≥ÿ™Ÿäÿ±ÿßÿØ ÿ¨ŸÖÿßÿπŸä <span class="feature-badge">ŸÖÿ≠ÿ≥ŸÜ</span>
                            </label>
                            <div class="row">
                                <div class="col-6">
                                    <input type="file" class="form-control" id="urlsFileInput" accept=".txt,.json">
                                    <small class="text-muted">ŸÖŸÑŸÅ .txt ÿ£Ÿà .json</small>
                                </div>
                                <div class="col-6">
                                    <button class="btn btn-outline-primary w-100" onclick="importUrlsFile()">
                                        üì• ÿßÿ≥ÿ™Ÿäÿ±ÿßÿØ ÿßŸÑÿ±Ÿàÿßÿ®ÿ∑
                                    </button>
                                </div>
                            </div>
                        </div>
                        
                        <div class="mb-3">
                            <label class="form-label">
                                ÿ±Ÿàÿßÿ®ÿ∑ ÿµŸÅÿ≠ÿßÿ™ ŸÖŸàŸÇÿπŸÉ <span class="pro-badge">Drag & Drop</span>
                            </label>
                            <div class="url-textarea-container">
                                <textarea class="form-control url-textarea-drop" id="urlInput" rows="6" 
                                    placeholder="index.html
about.html
services.html
contact.html
blog/article1.html
blog/article2.html

üí° ŸäŸÖŸÉŸÜŸÉ ÿ≥ÿ≠ÿ® Ÿàÿ•ŸÅŸÑÿßÿ™ ŸÖŸÑŸÅÿßÿ™ ÿßŸÑŸÜÿµŸàÿµ ŸáŸÜÿß ŸÖÿ®ÿßÿ¥ÿ±ÿ©!"></textarea>
                            </div>
                        </div>
                        
                        <div class="mb-3">
                            <label class="form-label">ÿ£Ÿà ÿ£ÿØÿÆŸÑ ŸÇÿßÿ¶ŸÖÿ© ŸäÿØŸàŸäÿ©:</label>
                            <div class="form-check">
                                <input class="form-check-input" type="checkbox" id="manualInput">
                                <label class="form-check-label" for="manualInput">
                                    ÿ•ÿØÿÆÿßŸÑ ŸäÿØŸàŸä ŸÑŸÑÿµŸÅÿ≠ÿßÿ™
                                </label>
                            </div>
                        </div>
                        
                        <div id="manualInputSection" style="display: none;">
                            <div class="mb-3">
                                <input type="text" class="form-control mb-2" id="pageTitle" placeholder="ÿπŸÜŸàÿßŸÜ ÿßŸÑÿµŸÅÿ≠ÿ©">
                                <input type="text" class="form-control mb-2" id="pageUrl" placeholder="ÿ±ÿßÿ®ÿ∑ ÿßŸÑÿµŸÅÿ≠ÿ©">
                                <input type="text" class="form-control mb-2" id="pageDescription" placeholder="ŸàÿµŸÅ ÿßŸÑÿµŸÅÿ≠ÿ©">
                                <input type="text" class="form-control mb-2" id="pageCategory" placeholder="ŸÅÿ¶ÿ© ÿßŸÑÿµŸÅÿ≠ÿ©">
                                <input type="text" class="form-control mb-2" id="pageTags" placeholder="ÿßŸÑŸÉŸÑŸÖÿßÿ™ ÿßŸÑŸÖŸÅÿ™ÿßÿ≠Ÿäÿ© (ŸÖŸÅÿµŸàŸÑÿ© ÿ®ŸÅŸàÿßÿµŸÑ)">
                                <button class="btn btn-success btn-sm" onclick="addManualPage()">ÿ•ÿ∂ÿßŸÅÿ© ÿµŸÅÿ≠ÿ©</button>
                            </div>
                        </div>
                        
                        <button class="btn btn-primary w-100" onclick="generateSearchIndex()">
                            üöÄ ÿ™ŸàŸÑŸäÿØ ŸÅŸáÿ±ÿ≥ ÿßŸÑÿ®ÿ≠ÿ´
                        </button>
                        
                        <!-- Data Management -->
                        <div class="mt-3">
                            <div class="row">
                                <div class="col-4">
                                    <button class="btn btn-outline-success w-100 btn-sm" onclick="saveToLocalStorage()">
                                        üíæ ÿ≠ŸÅÿ∏
                                    </button>
                                </div>
                                <div class="col-4">
                                    <button class="btn btn-outline-info w-100 btn-sm" onclick="loadFromLocalStorage()">
                                        üìÇ ÿ™ÿ≠ŸÖŸäŸÑ
                                    </button>
                                </div>
                                <div class="col-4">
                                    <button class="btn btn-outline-danger w-100 btn-sm" onclick="deleteAllData()">
                                        üóëÔ∏è ÿ≠ÿ∞ŸÅ ÿßŸÑŸÉŸÑ
                                    </button>
                                </div>
                            </div>
                            <small class="text-muted d-block mt-1">ÿßŸÑÿ®ŸäÿßŸÜÿßÿ™ ŸÖÿ≠ŸÅŸàÿ∏ÿ© ŸÖÿ≠ŸÑŸäŸãÿß ŸÅŸä ÿßŸÑŸÖÿ™ÿµŸÅÿ≠</small>
                        </div>
                    </div>
                </div>
            </div>
            
            <div class="col-md-6">
                <div class="card">
                    <div class="card-header">
                        <h3>üìä ÿßŸÑŸÜÿ™ÿßÿ¶ÿ¨ <span class="pro-badge">ŸÇÿßÿ®ŸÑ ŸÑŸÑÿ™ÿ≠ÿ±Ÿäÿ±</span></h3>
                    </div>
                    <div class="card-body">
                        <!-- Statistics Panel -->
                        <div class="stats-panel" id="statsPanel" style="display: none;">
                            <h6>üìà ÿ•ÿ≠ÿµÿßÿ¶Ÿäÿßÿ™ ÿØÿßÿÆŸÑŸäÿ©</h6>
                            <div class="stat-item">
                                <span>ÿπÿØÿØ ÿßŸÑÿµŸÅÿ≠ÿßÿ™:</span>
                                <strong id="statPages">0</strong>
                            </div>
                            <div class="stat-item">
                                <span>ÿ•ÿ¨ŸÖÿßŸÑŸä ÿßŸÑŸÉŸÑŸÖÿßÿ™ ÿßŸÑŸÖŸÅÿ™ÿßÿ≠Ÿäÿ©:</span>
                                <strong id="statKeywords">0</strong>
                            </div>
                            <div class="stat-item">
                                <span>ÿßŸÑŸÅÿ¶ÿßÿ™ ÿßŸÑŸÖÿÆÿ™ŸÑŸÅÿ©:</span>
                                <strong id="statCategories">0</strong>
                            </div>
                            <div class="stat-item">
                                <span>ÿ£ŸÉÿ´ÿ± ÿßŸÑŸÉŸÑŸÖÿßÿ™ ÿ™ŸÉÿ±ÿßÿ±ÿßŸã:</span>
                                <strong id="statTopKeyword">-</strong>
                            </div>
                        </div>

                        <!-- Filter Section -->
                        <div class="filter-section" id="filterSection" style="display: none;">
                            <h6>üîç ÿ™ÿµŸÅŸäÿ© ÿßŸÑŸÜÿ™ÿßÿ¶ÿ¨</h6>
                            <div class="row">
                                <div class="col-6">
                                    <select class="form-select form-select-sm" id="categoryFilter">
                                        <option value="">ÿ¨ŸÖŸäÿπ ÿßŸÑŸÅÿ¶ÿßÿ™</option>
                                    </select>
                                </div>
                                <div class="col-6">
                                    <input type="text" class="form-control form-control-sm" id="keywordFilter" placeholder="ÿ®ÿ≠ÿ´ ÿ®ÿßŸÑŸÉŸÑŸÖÿ© ÿßŸÑŸÖŸÅÿ™ÿßÿ≠Ÿäÿ©">
                                </div>
                            </div>
                        </div>

                        <div id="results" class="result-box">
                            <p class="text-muted text-center">ÿ£ÿØÿÆŸÑ ÿ±Ÿàÿßÿ®ÿ∑ ÿßŸÑÿµŸÅÿ≠ÿßÿ™ ÿ£Ÿà ÿßÿ±ŸÅÿπ ŸÖŸÑŸÅÿßÿ™ HTML/Sitemap Ÿàÿßÿ∂ÿ∫ÿ∑ "ÿ™ŸàŸÑŸäÿØ ŸÅŸáÿ±ÿ≥ ÿßŸÑÿ®ÿ≠ÿ´"</p>
                        </div>
                        
                        <!-- Enhanced Export Options -->
                        <div class="export-buttons" id="exportButtons" style="display: none;">
                            <button class="btn btn-success" onclick="downloadJson()">
                                üíæ JSON
                            </button>
                            
                            <button class="btn btn-info" onclick="downloadCSV()">
                                üìä CSV
                            </button>
                            
                            <button class="btn btn-warning" onclick="downloadZip()">
                                üì¶ ZIP
                            </button>
                            
                            <button class="btn btn-secondary" onclick="toggleCopyOptions()">
                                üìã ŸÜÿ≥ÿÆ
                            </button>
                        </div>

                        <!-- ZIP Progress -->
                        <div class="zip-progress" id="zipProgress">
                            <div class="progress">
                                <div class="progress-bar progress-bar-striped progress-bar-animated" id="zipProgressBar" role="progressbar" style="width: 0%"></div>
                            </div>
                            <small class="text-muted" id="zipProgressText">ÿ¨ÿßÿ±Ÿä ÿ•ŸÜÿ¥ÿßÿ° ŸÖŸÑŸÅ ZIP...</small>
                        </div>

                        <!-- Copy Options -->
                        <div class="copy-options" id="copyOptions">
                            <h6>ÿÆŸäÿßÿ±ÿßÿ™ ÿßŸÑŸÜÿ≥ÿÆ:</h6>
                            <div class="d-grid gap-2">
                                <button class="btn btn-outline-primary btn-sm" onclick="copyToClipboard('all')">
                                    üìã ŸÜÿ≥ÿÆ ŸÉÿßŸÖŸÑ (JSON)
                                </button>
                                <button class="btn btn-outline-secondary btn-sm" onclick="copyToClipboard('titles')">
                                    üìù ŸÜÿ≥ÿÆ ÿßŸÑÿπŸÜÿßŸàŸäŸÜ ŸÅŸÇÿ∑
                                </button>
                                <button class="btn btn-outline-info btn-sm" onclick="copyToClipboard('urls')">
                                    üîó ŸÜÿ≥ÿÆ ÿßŸÑÿ±Ÿàÿßÿ®ÿ∑ ŸÅŸÇÿ∑
                                </button>
                                <button class="btn btn-outline-success btn-sm" onclick="copyToClipboard('descriptions')">
                                    üìÑ ŸÜÿ≥ÿÆ ÿßŸÑÿ£ŸàÿµÿßŸÅ ŸÅŸÇÿ∑
                                </button>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
        
        <div class="row mt-5">
            <div class="col-12">
                <div class="alert alert-info">
                    <h4>üìñ ÿ™ÿπŸÑŸäŸÖÿßÿ™ ÿßŸÑÿßÿ≥ÿ™ÿÆÿØÿßŸÖ:</h4>
                    <ol>
                        <li><strong>ÿ¨ÿØŸäÿØ:</strong> ÿ£ÿØÿÆŸÑ ÿ±ÿßÿ®ÿ∑ GitHub Pages ŸÑÿ¨ŸÑÿ® Ÿàÿ™ÿ≠ŸÑŸäŸÑ ÿ¨ŸÖŸäÿπ ÿßŸÑÿµŸÅÿ≠ÿßÿ™ ÿ™ŸÑŸÇÿßÿ¶ŸäÿßŸã</li>
                        <li><strong>ÿ¨ÿØŸäÿØ:</strong> ÿßÿ±ŸÅÿπ ŸÖŸÑŸÅ robots.txt ŸÑÿßÿ≥ÿ™ÿÆÿ±ÿßÿ¨ ÿßŸÑÿµŸÅÿ≠ÿßÿ™ ÿßŸÑŸÖÿ≥ÿ™ÿ®ÿπÿØÿ© ŸàÿßŸÑŸÖÿ≥ŸÖŸàÿ≠ÿ©</li>
                        <li><strong>ÿ¨ÿØŸäÿØ:</strong> ÿßÿ±ŸÅÿπ ŸÖŸÑŸÅ manifest.json ŸÑÿßÿ≥ÿ™ÿÆÿ±ÿßÿ¨ ÿ£ÿ≥ŸÖÿßÿ° ÿ£ŸÇÿ≥ÿßŸÖ ÿ™ÿ∑ÿ®ŸäŸÇ PWA</li>
                        <li><strong>ŸÖÿ≠ÿ≥ŸÜ:</strong> ÿßÿ±ŸÅÿπ ŸÖŸÑŸÅ sitemap.xml ŸÑÿßÿ≥ÿ™ÿÆÿ±ÿßÿ¨ ÿ¨ŸÖŸäÿπ ÿßŸÑÿ±Ÿàÿßÿ®ÿ∑ ÿ™ŸÑŸÇÿßÿ¶ŸäÿßŸã</li>
                        <li><strong>ŸÖÿ≠ÿ≥ŸÜ:</strong> ÿßÿ±ŸÅÿπ ŸÖŸÑŸÅÿßÿ™ HTML ŸÖÿ®ÿßÿ¥ÿ±ÿ© ŸÑÿßÿ≥ÿ™ÿÆÿ±ÿßÿ¨ ÿßŸÑÿπŸÜÿßŸàŸäŸÜ ŸàÿßŸÑÿ£ŸàÿµÿßŸÅ ÿ™ŸÑŸÇÿßÿ¶ŸäŸãÿß</li>
                        <li><strong>ŸÖÿ≠ÿ≥ŸÜ:</strong> ÿßÿ≥ÿ≠ÿ® Ÿàÿ£ŸÅŸÑÿ™ ŸÖŸÑŸÅÿßÿ™ ÿßŸÑŸÜÿµŸàÿµ ŸÅŸä ŸÖŸÜÿ∑ŸÇÿ© ÿßŸÑÿ±Ÿàÿßÿ®ÿ∑</li>
                        <li>ÿ£Ÿà ÿ£ÿØÿÆŸÑ ÿ±Ÿàÿßÿ®ÿ∑ ÿ¨ŸÖŸäÿπ ÿµŸÅÿ≠ÿßÿ™ ŸÖŸàŸÇÿπŸÉ ŸäÿØŸàŸäÿßŸã</li>
                        <li>ÿßÿ∂ÿ∫ÿ∑ "ÿ™ŸàŸÑŸäÿØ ŸÅŸáÿ±ÿ≥ ÿßŸÑÿ®ÿ≠ÿ´"</li>
                        <li><strong>ÿ¨ÿØŸäÿØ:</strong> ÿ±ÿßÿ¨ÿπ ÿßŸÑÿ•ÿ≠ÿµÿßÿ¶Ÿäÿßÿ™ ÿßŸÑÿØÿßÿÆŸÑŸäÿ© ŸàÿßŸÑÿπÿØÿßÿØ ÿßŸÑŸÖÿ®ÿßÿ¥ÿ±</li>
                        <li><strong>ÿ¨ÿØŸäÿØ:</strong> ÿßÿ≥ÿ™ÿÆÿØŸÖ ÿßŸÑÿ™ÿµŸÅŸäÿ© ŸÑŸÑÿ®ÿ≠ÿ´ ŸÅŸä ÿßŸÑŸÜÿ™ÿßÿ¶ÿ¨</li>
                        <li><strong>ŸÖÿ≠ÿ≥ŸÜ:</strong> ÿπÿØŸëŸÑ ÿßŸÑŸÖÿ≠ÿ™ŸàŸâ ŸÖÿ®ÿßÿ¥ÿ±ÿ© ŸÅŸä ÿßŸÑŸÜÿ™ÿßÿ¶ÿ¨</li>
                        <li><strong>ŸÖÿ≠ÿ≥ŸÜ:</strong> ÿµÿØŸëÿ± ŸÉŸÄ JSONÿå CSVÿå ÿ£Ÿà ZIP ÿ¥ÿßŸÖŸÑ</li>
                        <li><strong>ŸÖÿ≠ÿ≥ŸÜ:</strong> ÿßŸÜÿ≥ÿÆ ÿßŸÑÿπŸÜÿßŸàŸäŸÜ ÿ£Ÿà ÿßŸÑÿ±Ÿàÿßÿ®ÿ∑ ÿ£Ÿà ÿßŸÑÿ£ŸàÿµÿßŸÅ ŸÖŸÜŸÅÿ±ÿØÿ©</li>
                        <li><strong>ÿ™ŸÑŸÇÿßÿ¶Ÿä:</strong> ÿßŸÑÿ®ŸäÿßŸÜÿßÿ™ ŸÖÿ≠ŸÅŸàÿ∏ÿ© ÿ™ŸÑŸÇÿßÿ¶ŸäÿßŸã ŸÅŸä ÿßŸÑŸÖÿ™ÿµŸÅÿ≠</li>
                    </ol>
                </div>
            </div>
        </div>
    </div>

    <!-- Toast Container -->
    <div class="toast-container position-fixed top-0 end-0 p-3" style="z-index: 9999;">
    </div>

    <!-- Bootstrap JS for Toast functionality -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/bootstrap/5.3.0/js/bootstrap.bundle.min.js"></script>

    <script>
        let searchIndex = [];
        let manualPages = [];
        let analyzedFiles = [];
        let sitemapUrls = [];
        let robotsUrls = [];
        let manifestData = {};
        let githubUrls = [];
        let isDarkMode = localStorage.getItem('darkMode') === 'true';
        let filteredResults = [];
        
        // Initialize dark mode
        if (isDarkMode) {
            document.documentElement.setAttribute('data-theme', 'dark');
            updateDarkModeButton();
        }
        
        // Auto-load data on page load
        window.addEventListener('load', function() {
            loadFromLocalStorage();
            setupTextareaDragDrop();
            setupDropZones();
            setupFilters();
        });
        
        // Dark mode functionality
        function toggleDarkMode() {
            isDarkMode = !isDarkMode;
            localStorage.setItem('darkMode', isDarkMode);
            
            if (isDarkMode) {
                document.documentElement.setAttribute('data-theme', 'dark');
            } else {
                document.documentElement.removeAttribute('data-theme');
            }
            
            updateDarkModeButton();
            showNotification(isDarkMode ? 'ÿ™ŸÖ ÿ™ŸÅÿπŸäŸÑ ÿßŸÑŸàÿ∂ÿπ ÿßŸÑŸÑŸäŸÑŸä üåô' : 'ÿ™ŸÖ ÿ™ŸÅÿπŸäŸÑ ÿßŸÑŸàÿ∂ÿπ ÿßŸÑŸÜŸáÿßÿ±Ÿä ‚òÄÔ∏è', 'info');
        }
        
        function updateDarkModeButton() {
            const button = document.querySelector('.dark-mode-toggle');
            button.innerHTML = isDarkMode ? '‚òÄÔ∏è ÿßŸÑŸàÿ∂ÿπ ÿßŸÑŸÜŸáÿßÿ±Ÿä' : 'üåô ÿßŸÑŸàÿ∂ÿπ ÿßŸÑŸÑŸäŸÑŸä';
        }

        // Live counter functionality
        function updateLiveCounter() {
            const counter = document.getElementById('liveCounter');
            const counterValue = document.getElementById('counterValue');
            
            if (searchIndex.length > 0) {
                counter.style.display = 'block';
                counterValue.textContent = searchIndex.length;
            } else {
                counter.style.display = 'none';
            }
        }

        // Statistics functionality
        function updateStatistics() {
            const statsPanel = document.getElementById('statsPanel');
            
            if (searchIndex.length === 0) {
                statsPanel.style.display = 'none';
                return;
            }

            statsPanel.style.display = 'block';
            
            // Calculate statistics
            const totalPages = searchIndex.length;
            const allKeywords = searchIndex.flatMap(item => item.tags || []);
            const totalKeywords = allKeywords.length;
            const uniqueCategories = [...new Set(searchIndex.map(item => item.category))].length;
            
            // Find most frequent keyword
            const keywordCount = {};
            allKeywords.forEach(keyword => {
                keywordCount[keyword] = (keywordCount[keyword] || 0) + 1;
            });
            
            const topKeyword = Object.keys(keywordCount).reduce((a, b) => 
                keywordCount[a] > keywordCount[b] ? a : b, '-'
            );
            
            // Update display
            document.getElementById('statPages').textContent = totalPages;
            document.getElementById('statKeywords').textContent = totalKeywords;
            document.getElementById('statCategories').textContent = uniqueCategories;
            document.getElementById('statTopKeyword').textContent = topKeyword + (keywordCount[topKeyword] ? ` (${keywordCount[topKeyword]})` : '');
        }

        // Filter functionality
        function setupFilters() {
            const categoryFilter = document.getElementById('categoryFilter');
            const keywordFilter = document.getElementById('keywordFilter');
            
            categoryFilter.addEventListener('change', applyFilters);
            keywordFilter.addEventListener('input', applyFilters);
        }

        function updateFilterOptions() {
            const categoryFilter = document.getElementById('categoryFilter');
            const categories = [...new Set(searchIndex.map(item => item.category))];
            
            categoryFilter.innerHTML = '<option value="">ÿ¨ŸÖŸäÿπ ÿßŸÑŸÅÿ¶ÿßÿ™</option>';
            categories.forEach(category => {
                const option = document.createElement('option');
                option.value = category;
                option.textContent = category;
                categoryFilter.appendChild(option);
            });
        }

        function applyFilters() {
            const categoryFilter = document.getElementById('categoryFilter').value;
            const keywordFilter = document.getElementById('keywordFilter').value.toLowerCase();
            
            filteredResults = searchIndex.filter(item => {
                const matchesCategory = !categoryFilter || item.category === categoryFilter;
                const matchesKeyword = !keywordFilter || 
                    item.title.toLowerCase().includes(keywordFilter) ||
                    item.description.toLowerCase().includes(keywordFilter) ||
                    (item.tags && item.tags.some(tag => tag.toLowerCase().includes(keywordFilter)));
                
                return matchesCategory && matchesKeyword;
            });
            
            displayResults(filteredResults);
        }

        // Delete all data functionality
        function deleteAllData() {
            if (confirm('ŸáŸÑ ÿ£ŸÜÿ™ ŸÖÿ™ÿ£ŸÉÿØ ŸÖŸÜ ÿ≠ÿ∞ŸÅ ÿ¨ŸÖŸäÿπ ÿßŸÑÿ®ŸäÿßŸÜÿßÿ™ÿü ŸÑÿß ŸäŸÖŸÉŸÜ ÿßŸÑÿ™ÿ±ÿßÿ¨ÿπ ÿπŸÜ Ÿáÿ∞ÿß ÿßŸÑÿ•ÿ¨ÿ±ÿßÿ°.')) {
                searchIndex = [];
                manualPages = [];
                analyzedFiles = [];
                sitemapUrls = [];
                robotsUrls = [];
                manifestData = {};
                githubUrls = [];
                filteredResults = [];
                
                document.getElementById('urlInput').value = '';
                document.getElementById('results').innerHTML = '<p class="text-muted text-center">ÿ™ŸÖ ÿ≠ÿ∞ŸÅ ÿ¨ŸÖŸäÿπ ÿßŸÑÿ®ŸäÿßŸÜÿßÿ™</p>';
                document.getElementById('exportButtons').style.display = 'none';
                document.getElementById('statsPanel').style.display = 'none';
                document.getElementById('filterSection').style.display = 'none';
                
                updateLiveCounter();
                localStorage.removeItem('searchIndexGenerator');
                
                showNotification('ÿ™ŸÖ ÿ≠ÿ∞ŸÅ ÿ¨ŸÖŸäÿπ ÿßŸÑÿ®ŸäÿßŸÜÿßÿ™ ÿ®ŸÜÿ¨ÿßÿ≠! üóëÔ∏è', 'success');
            }
        }

        // GitHub Pages fetch functionality
        async function fetchFromGitHub() {
            const githubUrl = document.getElementById('githubUrl').value.trim();
            
            if (!githubUrl) {
                showNotification('Ÿäÿ±ÿ¨Ÿâ ÿ•ÿØÿÆÿßŸÑ ÿ±ÿßÿ®ÿ∑ GitHub Pages ÿµÿßŸÑÿ≠', 'warning');
                return;
            }
            
            try {
                showNotification('ÿ¨ÿßÿ±Ÿä ÿ¨ŸÑÿ® ÿßŸÑÿ®ŸäÿßŸÜÿßÿ™ ŸÖŸÜ GitHub Pages...', 'info');
                
                // This is a simplified implementation
                // In a real scenario, you'd need to handle CORS and use GitHub API
                const response = await fetch(githubUrl);
                const html = await response.text();
                
                // Extract links from the main page
                const parser = new DOMParser();
                const doc = parser.parseFromString(html, 'text/html');
                const links = Array.from(doc.querySelectorAll('a[href]'))
                    .map(a => a.getAttribute('href'))
                    .filter(href => href && href.endsWith('.html') && !href.startsWith('http'))
                    .map(href => href.startsWith('/') ? href : '/' + href);
                
                if (links.length > 0) {
                    githubUrls = links;
                    const currentUrls = document.getElementById('urlInput').value;
                    const newUrls = currentUrls ? currentUrls + '\n' + links.join('\n') : links.join('\n');
                    document.getElementById('urlInput').value = newUrls;
                    
                    showNotification(`ÿ™ŸÖ ÿ¨ŸÑÿ® ${links.length} ÿ±ÿßÿ®ÿ∑ ŸÖŸÜ GitHub Pages! üêô`, 'success');
                    autoSave();
                } else {
                    showNotification('ŸÑŸÖ Ÿäÿ™ŸÖ ÿßŸÑÿπÿ´Ÿàÿ± ÿπŸÑŸâ ÿ±Ÿàÿßÿ®ÿ∑ HTML ŸÅŸä ÿßŸÑÿµŸÅÿ≠ÿ©', 'warning');
                }
                
            } catch (error) {
                showNotification('ÿÆÿ∑ÿ£ ŸÅŸä ÿ¨ŸÑÿ® ÿßŸÑÿ®ŸäÿßŸÜÿßÿ™ ŸÖŸÜ GitHub: ' + error.message, 'danger');
            }
        }

        // Setup all drop zones
        function setupDropZones() {
            setupRobotsDropZone();
            setupManifestDropZone();
            setupSitemapDropZone();
        }

        // Robots.txt functionality
        function setupRobotsDropZone() {
            const robotsDropZone = document.getElementById('robotsDropZone');
            const robotsFileInput = document.getElementById('robotsFileInput');
            
            robotsDropZone.addEventListener('click', () => robotsFileInput.click());
            
            robotsDropZone.addEventListener('dragover', (e) => {
                e.preventDefault();
                robotsDropZone.classList.add('dragover');
            });
            
            robotsDropZone.addEventListener('dragleave', () => {
                robotsDropZone.classList.remove('dragover');
            });
            
            robotsDropZone.addEventListener('drop', (e) => {
                e.preventDefault();
                robotsDropZone.classList.remove('dragover');
                const files = Array.from(e.dataTransfer.files).filter(file => 
                    file.type === 'text/plain' || file.name.endsWith('.txt')
                );
                if (files.length > 0) {
                    processRobotsFile(files[0]);
                }
            });
            
            robotsFileInput.addEventListener('change', (e) => {
                if (e.target.files.length > 0) {
                    processRobotsFile(e.target.files[0]);
                }
            });
        }

        async function processRobotsFile(file) {
            try {
                const content = await readFileContent(file);
                const lines = content.split('\n').map(line => line.trim());
                
                const newRobotsUrls = [];
                let currentUserAgent = '*';
                
                lines.forEach(line => {
                    if (line.toLowerCase().startsWith('user-agent:')) {
                        currentUserAgent = line.split(':')[1].trim();
                    } else if (line.toLowerCase().startsWith('disallow:')) {
                        const path = line.split(':')[1].trim();
                        if (path && path !== '/' && !robotsUrls.includes(path) && !newRobotsUrls.includes(path)) {
                            newRobotsUrls.push(path);
                        }
                    } else if (line.toLowerCase().startsWith('allow:')) {
                        const path = line.split(':')[1].trim();
                        if (path && path !== '/' && !robotsUrls.includes(path) && !newRobotsUrls.includes(path)) {
                            newRobotsUrls.push(path);
                        }
                    }
                });
                
                if (newRobotsUrls.length > 0) {
                    // Append to existing robotsUrls
                    robotsUrls.push(...newRobotsUrls);
                    
                    const currentUrls = document.getElementById('urlInput').value;
                    const newUrls = currentUrls ? currentUrls + '\n' + newRobotsUrls.join('\n') : newRobotsUrls.join('\n');
                    document.getElementById('urlInput').value = newUrls;
                    
                    showNotification(`ÿ™ŸÖ ÿßÿ≥ÿ™ÿÆÿ±ÿßÿ¨ ${newRobotsUrls.length} ŸÖÿ≥ÿßÿ± ÿ¨ÿØŸäÿØ ŸÖŸÜ robots.txt! ü§ñ`, 'success');
                    autoSave();
                } else {
                    showNotification('ŸÑŸÖ Ÿäÿ™ŸÖ ÿßŸÑÿπÿ´Ÿàÿ± ÿπŸÑŸâ ŸÖÿ≥ÿßÿ±ÿßÿ™ ÿ¨ÿØŸäÿØÿ© ŸÅŸä ŸÖŸÑŸÅ robots.txt', 'warning');
                }
                
            } catch (error) {
                showNotification('ÿÆÿ∑ÿ£ ŸÅŸä ŸÖÿπÿßŸÑÿ¨ÿ© ŸÖŸÑŸÅ robots.txt: ' + error.message, 'danger');
            }
        }

        // Manifest.json functionality
        function setupManifestDropZone() {
            const manifestDropZone = document.getElementById('manifestDropZone');
            const manifestFileInput = document.getElementById('manifestFileInput');
            
            manifestDropZone.addEventListener('click', () => manifestFileInput.click());
            
            manifestDropZone.addEventListener('dragover', (e) => {
                e.preventDefault();
                manifestDropZone.classList.add('dragover');
            });
            
            manifestDropZone.addEventListener('dragleave', () => {
                manifestDropZone.classList.remove('dragover');
            });
            
            manifestDropZone.addEventListener('drop', (e) => {
                e.preventDefault();
                manifestDropZone.classList.remove('dragover');
                const files = Array.from(e.dataTransfer.files).filter(file => 
                    file.type === 'application/json' || file.name.endsWith('.json')
                );
                if (files.length > 0) {
                    processManifestFile(files[0]);
                }
            });
            
            manifestFileInput.addEventListener('change', (e) => {
                if (e.target.files.length > 0) {
                    processManifestFile(e.target.files[0]);
                }
            });
        }

        async function processManifestFile(file) {
            try {
                const content = await readFileContent(file);
                manifestData = JSON.parse(content);
                
                const extractedUrls = [];
                
                // Extract from icons
                if (manifestData.icons) {
                    manifestData.icons.forEach(icon => {
                        if (icon.src) {
                            extractedUrls.push(icon.src);
                        }
                    });
                }
                
                // Extract from screenshots
                if (manifestData.screenshots) {
                    manifestData.screenshots.forEach(screenshot => {
                        if (screenshot.src) {
                            extractedUrls.push(screenshot.src);
                        }
                    });
                }
                
                // Extract start_url
                if (manifestData.start_url) {
                    extractedUrls.push(manifestData.start_url);
                }
                
                // Extract from shortcuts
                if (manifestData.shortcuts) {
                    manifestData.shortcuts.forEach(shortcut => {
                        if (shortcut.url) {
                            extractedUrls.push(shortcut.url);
                        }
                    });
                }
                
                if (extractedUrls.length > 0) {
                    const currentUrls = document.getElementById('urlInput').value;
                    const newUrls = currentUrls ? currentUrls + '\n' + extractedUrls.join('\n') : extractedUrls.join('\n');
                    document.getElementById('urlInput').value = newUrls;
                    
                    showNotification(`ÿ™ŸÖ ÿßÿ≥ÿ™ÿÆÿ±ÿßÿ¨ ${extractedUrls.length} ŸÖÿ≥ÿßÿ± ŸÖŸÜ manifest.json! üì±`, 'success');
                    autoSave();
                } else {
                    showNotification('ŸÑŸÖ Ÿäÿ™ŸÖ ÿßŸÑÿπÿ´Ÿàÿ± ÿπŸÑŸâ ŸÖÿ≥ÿßÿ±ÿßÿ™ ÿµÿßŸÑÿ≠ÿ© ŸÅŸä ŸÖŸÑŸÅ manifest.json', 'warning');
                }
                
            } catch (error) {
                showNotification('ÿÆÿ∑ÿ£ ŸÅŸä ŸÖÿπÿßŸÑÿ¨ÿ© ŸÖŸÑŸÅ manifest.json: ' + error.message, 'danger');
            }
        }
        
        // Setup drag and drop for textarea
        function setupTextareaDragDrop() {
            const textarea = document.getElementById('urlInput');
            
            textarea.addEventListener('dragover', (e) => {
                e.preventDefault();
                textarea.classList.add('dragover');
            });
            
            textarea.addEventListener('dragleave', () => {
                textarea.classList.remove('dragover');
            });
            
            textarea.addEventListener('drop', (e) => {
                e.preventDefault();
                textarea.classList.remove('dragover');
                
                const files = Array.from(e.dataTransfer.files).filter(file => 
                    file.type === 'text/plain' || file.name.endsWith('.txt') || file.name.endsWith('.json')
                );
                
                if (files.length > 0) {
                    processDroppedTextFiles(files);
                }
            });
        }
        
        async function processDroppedTextFiles(files) {
            for (const file of files) {
                try {
                    const content = await readFileContent(file);
                    let urls = [];
                    
                    if (file.name.endsWith('.json')) {
                        const jsonData = JSON.parse(content);
                        if (Array.isArray(jsonData)) {
                            urls = jsonData;
                        } else if (jsonData.urls && Array.isArray(jsonData.urls)) {
                            urls = jsonData.urls;
                        }
                    } else {
                        urls = content.split('\n')
                            .map(line => line.trim())
                            .filter(line => line && !line.startsWith('#'));
                    }
                    
                    if (urls.length > 0) {
                        const currentUrls = document.getElementById('urlInput').value;
                        const newUrls = currentUrls ? currentUrls + '\n' + urls.join('\n') : urls.join('\n');
                        document.getElementById('urlInput').value = newUrls;
                        showNotification(`ÿ™ŸÖ ÿ•ÿ∂ÿßŸÅÿ© ${urls.length} ÿ±ÿßÿ®ÿ∑ ŸÖŸÜ ${file.name}! üì•`, 'success');
                        autoSave();
                    }
                } catch (error) {
                    showNotification(`ÿÆÿ∑ÿ£ ŸÅŸä ŸÖÿπÿßŸÑÿ¨ÿ© ${file.name}: ${error.message}`, 'danger');
                }
            }
        }
        
        // Auto-save data when changes occur
        function autoSave() {
            saveToLocalStorage();
        }
        
        // LocalStorage functions
        function saveToLocalStorage() {
            const data = {
                searchIndex: searchIndex,
                manualPages: manualPages,
                analyzedFiles: analyzedFiles,
                sitemapUrls: sitemapUrls,
                robotsUrls: robotsUrls,
                manifestData: manifestData,
                githubUrls: githubUrls,
                urlInput: document.getElementById('urlInput').value,
                timestamp: new Date().toISOString()
            };
            
            try {
                localStorage.setItem('searchIndexGenerator', JSON.stringify(data));
                showNotification('ÿ™ŸÖ ÿ≠ŸÅÿ∏ ÿßŸÑÿ®ŸäÿßŸÜÿßÿ™ ÿ®ŸÜÿ¨ÿßÿ≠! ‚úÖ', 'success');
            } catch (error) {
                showNotification('ÿÆÿ∑ÿ£ ŸÅŸä ÿ≠ŸÅÿ∏ ÿßŸÑÿ®ŸäÿßŸÜÿßÿ™: ' + error.message, 'danger');
            }
        }
        
        function loadFromLocalStorage() {
            try {
                const savedData = localStorage.getItem('searchIndexGenerator');
                if (savedData) {
                    const data = JSON.parse(savedData);
                    searchIndex = data.searchIndex || [];
                    manualPages = data.manualPages || [];
                    analyzedFiles = data.analyzedFiles || [];
                    sitemapUrls = data.sitemapUrls || [];
                    robotsUrls = data.robotsUrls || [];
                    manifestData = data.manifestData || {};
                    githubUrls = data.githubUrls || [];
                    
                    if (data.urlInput) {
                        document.getElementById('urlInput').value = data.urlInput;
                    }
                    
                    if (searchIndex.length > 0) {
                        displayResults();
                        updateStatistics();
                        updateLiveCounter();
                        updateFilterOptions();
                        document.getElementById('filterSection').style.display = 'block';
                    }
                    
                    showNotification('ÿ™ŸÖ ÿ™ÿ≠ŸÖŸäŸÑ ÿßŸÑÿ®ŸäÿßŸÜÿßÿ™ ÿßŸÑŸÖÿ≠ŸÅŸàÿ∏ÿ©! üìÇ', 'info');
                }
            } catch (error) {
                showNotification('ÿÆÿ∑ÿ£ ŸÅŸä ÿ™ÿ≠ŸÖŸäŸÑ ÿßŸÑÿ®ŸäÿßŸÜÿßÿ™: ' + error.message, 'warning');
            }
        }
        
        // Enhanced notification system using Bootstrap 5.3 Toasts
        function showNotification(message, type = 'info') {
            const toastContainer = document.querySelector('.toast-container');
            const toastId = 'toast-' + Date.now();
            
            // Map notification types to Bootstrap toast styles
            const typeMapping = {
                'info': { bg: 'bg-info', icon: '‚ÑπÔ∏è', title: 'ŸÖÿπŸÑŸàŸÖÿßÿ™' },
                'success': { bg: 'bg-success', icon: '‚úÖ', title: 'ŸÜÿ¨ÿ≠' },
                'warning': { bg: 'bg-warning', icon: '‚ö†Ô∏è', title: 'ÿ™ÿ≠ÿ∞Ÿäÿ±' },
                'danger': { bg: 'bg-danger', icon: '‚ùå', title: 'ÿÆÿ∑ÿ£' },
                'error': { bg: 'bg-danger', icon: '‚ùå', title: 'ÿÆÿ∑ÿ£' }
            };
            
            const toastConfig = typeMapping[type] || typeMapping['info'];
            
            // Create toast element
            const toastElement = document.createElement('div');
            toastElement.id = toastId;
            toastElement.className = `toast fade show ${toastConfig.bg} text-white`;
            toastElement.setAttribute('role', 'alert');
            toastElement.setAttribute('aria-live', 'assertive');
            toastElement.setAttribute('aria-atomic', 'true');
            
            toastElement.innerHTML = `
                <div class="toast-header ${toastConfig.bg} text-white border-0">
                    <span class="me-2">${toastConfig.icon}</span>
                    <strong class="me-auto">${toastConfig.title}</strong>
                    <small class="opacity-75">ÿßŸÑÿ¢ŸÜ</small>
                    <button type="button" class="btn-close btn-close-white ms-2" data-bs-dismiss="toast" aria-label="ÿ•ÿ∫ŸÑÿßŸÇ"></button>
                </div>
                <div class="toast-body">
                    ${message}
                </div>
            `;
            
            // Add to container
            toastContainer.appendChild(toastElement);
            
            // Initialize Bootstrap toast
            const bsToast = new bootstrap.Toast(toastElement, {
                autohide: true,
                delay: 5000
            });
            
            // Show the toast
            bsToast.show();
            
            // Remove from DOM after it's hidden
            toastElement.addEventListener('hidden.bs.toast', () => {
                if (toastElement.parentNode) {
                    toastElement.parentNode.removeChild(toastElement);
                }
            });
        }
        
        // Sitemap.xml functionality
        function setupSitemapDropZone() {
            const sitemapDropZone = document.getElementById('sitemapDropZone');
            const sitemapFileInput = document.getElementById('sitemapFileInput');
            
            sitemapDropZone.addEventListener('click', () => sitemapFileInput.click());
            
            sitemapDropZone.addEventListener('dragover', (e) => {
                e.preventDefault();
                sitemapDropZone.classList.add('dragover');
            });
            
            sitemapDropZone.addEventListener('dragleave', () => {
                sitemapDropZone.classList.remove('dragover');
            });
            
            sitemapDropZone.addEventListener('drop', (e) => {
                e.preventDefault();
                sitemapDropZone.classList.remove('dragover');
                const files = Array.from(e.dataTransfer.files).filter(file => 
                    file.type === 'text/xml' || file.name.endsWith('.xml')
                );
                if (files.length > 0) {
                    processSitemapFile(files[0]);
                }
            });
            
            sitemapFileInput.addEventListener('change', (e) => {
                if (e.target.files.length > 0) {
                    processSitemapFile(e.target.files[0]);
                }
            });
        }
        
        async function processSitemapFile(file) {
            try {
                const content = await readFileContent(file);
                const parser = new DOMParser();
                const xmlDoc = parser.parseFromString(content, 'text/xml');
                
                // Check for parsing errors
                const parseError = xmlDoc.querySelector('parsererror');
                if (parseError) {
                    throw new Error('ÿÆÿ∑ÿ£ ŸÅŸä ÿ™ÿ≠ŸÑŸäŸÑ ŸÖŸÑŸÅ XML');
                }
                
                // Extract URLs from sitemap
                const urlElements = xmlDoc.querySelectorAll('url > loc, sitemap > loc');
                const newSitemapUrls = [];
                
                urlElements.forEach(element => {
                    let url = element.textContent.trim();
                    // Convert full URLs to relative paths
                    try {
                        const urlObj = new URL(url);
                        url = urlObj.pathname;
                        if (url === '/') url = '/index.html';
                        if (!url.includes('.')) url += '.html';
                    } catch (e) {
                        // If not a valid URL, treat as relative path
                    }
                    
                    if (url && !sitemapUrls.includes(url) && !newSitemapUrls.includes(url)) {
                        newSitemapUrls.push(url);
                    }
                });
                
                if (newSitemapUrls.length > 0) {
                    // Append to existing sitemapUrls
                    sitemapUrls.push(...newSitemapUrls);
                    
                    // Add to URL input
                    const currentUrls = document.getElementById('urlInput').value;
                    const newUrls = currentUrls ? currentUrls + '\n' + newSitemapUrls.join('\n') : newSitemapUrls.join('\n');
                    document.getElementById('urlInput').value = newUrls;
                    
                    showNotification(`ÿ™ŸÖ ÿßÿ≥ÿ™ÿÆÿ±ÿßÿ¨ ${newSitemapUrls.length} ÿ±ÿßÿ®ÿ∑ ÿ¨ÿØŸäÿØ ŸÖŸÜ Sitemap! üó∫Ô∏è`, 'success');
                    autoSave();
                } else {
                    showNotification('ŸÑŸÖ Ÿäÿ™ŸÖ ÿßŸÑÿπÿ´Ÿàÿ± ÿπŸÑŸâ ÿ±Ÿàÿßÿ®ÿ∑ ÿ¨ÿØŸäÿØÿ© ŸÅŸä ŸÖŸÑŸÅ Sitemap', 'warning');
                }
                
            } catch (error) {
                showNotification('ÿÆÿ∑ÿ£ ŸÅŸä ŸÖÿπÿßŸÑÿ¨ÿ© ŸÖŸÑŸÅ Sitemap: ' + error.message, 'danger');
            }
        }
        
        // File drop zone functionality
        const fileDropZone = document.getElementById('fileDropZone');
        const htmlFileInput = document.getElementById('htmlFileInput');
        
        fileDropZone.addEventListener('click', () => htmlFileInput.click());
        
        fileDropZone.addEventListener('dragover', (e) => {
            e.preventDefault();
            fileDropZone.classList.add('dragover');
        });
        
        fileDropZone.addEventListener('dragleave', () => {
            fileDropZone.classList.remove('dragover');
        });
        
        fileDropZone.addEventListener('drop', (e) => {
            e.preventDefault();
            fileDropZone.classList.remove('dragover');
            const files = Array.from(e.dataTransfer.files).filter(file => 
                file.type === 'text/html' || file.name.endsWith('.html') || file.name.endsWith('.htm')
            );
            if (files.length > 0) {
                processHtmlFiles(files);
            }
        });
        
        htmlFileInput.addEventListener('change', (e) => {
            if (e.target.files.length > 0) {
                processHtmlFiles(Array.from(e.target.files));
            }
        });
        
        // Process HTML files with enhanced content extraction
        async function processHtmlFiles(files) {
            const progressContainer = document.getElementById('progressContainer');
            const progressBar = document.getElementById('progressBar');
            const progressText = document.getElementById('progressText');
            
            progressContainer.style.display = 'block';
            // Don't reset analyzedFiles - append to existing data instead
            // analyzedFiles = []; // REMOVED: This was causing data loss
            
            const newAnalyzedFiles = [];
            
            for (let i = 0; i < files.length; i++) {
                const file = files[i];
                const progress = ((i + 1) / files.length) * 100;
                
                progressBar.style.width = progress + '%';
                progressText.textContent = `ŸÖÿπÿßŸÑÿ¨ÿ© ${file.name} (${i + 1}/${files.length})`;
                
                try {
                    // Check if this file was already analyzed
                    const existingAnalysis = analyzedFiles.find(existing => existing.filename === file.name);
                    
                    if (!existingAnalysis) {
                        const content = await readFileContent(file);
                        const analysis = analyzeHtmlContent(content, file.name);
                        analyzedFiles.push(analysis);
                        newAnalyzedFiles.push(analysis);
                    }
                } catch (error) {
                    console.error('Error processing file:', file.name, error);
                }
                
                // Small delay for UI responsiveness
                await new Promise(resolve => setTimeout(resolve, 100));
            }
            
            progressContainer.style.display = 'none';
            
            if (newAnalyzedFiles.length > 0) {
                showNotification(`ÿ™ŸÖ ÿ™ÿ≠ŸÑŸäŸÑ ${newAnalyzedFiles.length} ŸÖŸÑŸÅ HTML ÿ¨ÿØŸäÿØ ÿ®ŸÜÿ¨ÿßÿ≠! ÿ•ÿ¨ŸÖÿßŸÑŸä ÿßŸÑŸÖŸÑŸÅÿßÿ™: ${analyzedFiles.length} üéâ`, 'success');
            } else {
                showNotification('ÿ¨ŸÖŸäÿπ ÿßŸÑŸÖŸÑŸÅÿßÿ™ ÿ™ŸÖ ÿ™ÿ≠ŸÑŸäŸÑŸáÿß ŸÖÿ≥ÿ®ŸÇÿßŸã - ŸÑÿß ÿ™Ÿàÿ¨ÿØ ŸÖŸÑŸÅÿßÿ™ ÿ¨ÿØŸäÿØÿ©', 'info');
            }
            
            autoSave();
        }
        
        function readFileContent(file) {
            return new Promise((resolve, reject) => {
                const reader = new FileReader();
                reader.onload = e => resolve(e.target.result);
                reader.onerror = reject;
                reader.readAsText(file, 'UTF-8');
            });
        }
        
        function analyzeHtmlContent(content, filename) {
            const parser = new DOMParser();
            const doc = parser.parseFromString(content, 'text/html');
            
            // Extract title
            const titleElement = doc.querySelector('title');
            let title = titleElement ? titleElement.textContent.trim() : '';
            
            // Extract description from meta tags
            let description = '';
            const metaDesc = doc.querySelector('meta[name="description"]') || 
                           doc.querySelector('meta[property="og:description"]');
            if (metaDesc) {
                description = metaDesc.getAttribute('content') || '';
            }
            
            // Enhanced content extraction from article/main sections
            if (!description) {
                const articleElement = doc.querySelector('article');
                const mainElement = doc.querySelector('main');
                const contentElement = articleElement || mainElement;
                
                if (contentElement) {
                    const firstParagraph = contentElement.querySelector('p');
                    if (firstParagraph) {
                        description = firstParagraph.textContent.trim().substring(0, 200) + '...';
                    }
                }
            }
            
            // Extract keywords
            let keywords = [];
            const metaKeywords = doc.querySelector('meta[name="keywords"]');
            if (metaKeywords) {
                keywords = metaKeywords.getAttribute('content')
                    .split(',')
                    .map(k => k.trim())
                    .filter(k => k);
            }
            
            // Extract headings for additional context
            const headings = Array.from(doc.querySelectorAll('h1, h2, h3'))
                .map(h => h.textContent.trim())
                .filter(h => h);
            
            // Fallback title from filename
            if (!title) {
                title = filename.replace(/\.(html?|htm)$/i, '')
                    .replace(/[-_]/g, ' ')
                    .replace(/\b\w/g, l => l.toUpperCase());
            }
            
            // Fallback description
            if (!description && headings.length > 0) {
                description = `ÿµŸÅÿ≠ÿ© ${title} - ${headings[0]}`;
            } else if (!description) {
                description = `ÿµŸÅÿ≠ÿ© ${title}`;
            }
            
            return {
                filename: filename,
                title: title,
                description: description,
                keywords: keywords,
                headings: headings,
                url: '/' + filename,
                content: content // Store content for ZIP export
            };
        }
        
        // Enhanced tag extraction from URLs
        function extractTagsFromUrl(url) {
            const tags = [];
            const pathParts = url.split('/').filter(part => part && part !== '');
            
            pathParts.forEach(part => {
                // Remove file extensions
                const cleanPart = part.replace(/\.(html?|htm|php|asp|jsp)$/i, '');
                
                // Split by common separators
                const subParts = cleanPart.split(/[-_\s]+/);
                
                subParts.forEach(subPart => {
                    if (subPart.length > 2) {
                        tags.push(subPart.toLowerCase());
                    }
                });
            });
            
            // Add common Arabic translations
            const translations = {
                'index': 'ÿßŸÑÿ±ÿ¶Ÿäÿ≥Ÿäÿ©',
                'home': 'ÿßŸÑÿ±ÿ¶Ÿäÿ≥Ÿäÿ©',
                'about': 'ŸÖŸÜ ŸÜÿ≠ŸÜ',
                'contact': 'ÿßÿ™ÿµŸÑ ÿ®ŸÜÿß',
                'services': 'ÿÆÿØŸÖÿßÿ™',
                'products': 'ŸÖŸÜÿ™ÿ¨ÿßÿ™',
                'blog': 'ŸÖÿØŸàŸÜÿ©',
                'news': 'ÿ£ÿÆÿ®ÿßÿ±',
                'portfolio': 'ÿ£ÿπŸÖÿßŸÑ',
                'team': 'ŸÅÿ±ŸäŸÇ',
                'pricing': 'ÿ£ÿ≥ÿπÿßÿ±',
                'faq': 'ÿ£ÿ≥ÿ¶ŸÑÿ© ÿ¥ÿßÿ¶ÿπÿ©'
            };
            
            tags.forEach(tag => {
                if (translations[tag]) {
                    tags.push(translations[tag]);
                }
            });
            
            return [...new Set(tags)]; // Remove duplicates
        }
        
        // Bulk import functionality
        function importUrlsFile() {
            const fileInput = document.getElementById('urlsFileInput');
            const file = fileInput.files[0];
            
            if (!file) {
                alert('Ÿäÿ±ÿ¨Ÿâ ÿßÿÆÿ™Ÿäÿßÿ± ŸÖŸÑŸÅ ÿ£ŸàŸÑÿßŸã');
                return;
            }
            
            const reader = new FileReader();
            reader.onload = function(e) {
                const content = e.target.result;
                let urls = [];
                
                try {
                    if (file.name.endsWith('.json')) {
                        const jsonData = JSON.parse(content);
                        if (Array.isArray(jsonData)) {
                            urls = jsonData;
                        } else if (jsonData.urls && Array.isArray(jsonData.urls)) {
                            urls = jsonData.urls;
                        }
                    } else {
                        // Text file
                        urls = content.split('\n')
                            .map(line => line.trim())
                            .filter(line => line && !line.startsWith('#'));
                    }
                    
                    if (urls.length > 0) {
                        const currentUrls = document.getElementById('urlInput').value;
                        const newUrls = currentUrls ? currentUrls + '\n' + urls.join('\n') : urls.join('\n');
                        document.getElementById('urlInput').value = newUrls;
                        showNotification(`ÿ™ŸÖ ÿßÿ≥ÿ™Ÿäÿ±ÿßÿØ ${urls.length} ÿ±ÿßÿ®ÿ∑ ÿ®ŸÜÿ¨ÿßÿ≠! üì•`, 'success');
                        autoSave();
                    } else {
                        alert('ŸÑŸÖ Ÿäÿ™ŸÖ ÿßŸÑÿπÿ´Ÿàÿ± ÿπŸÑŸâ ÿ±Ÿàÿßÿ®ÿ∑ ÿµÿßŸÑÿ≠ÿ© ŸÅŸä ÿßŸÑŸÖŸÑŸÅ');
                    }
                } catch (error) {
                    alert('ÿÆÿ∑ÿ£ ŸÅŸä ŸÇÿ±ÿßÿ°ÿ© ÿßŸÑŸÖŸÑŸÅ: ' + error.message);
                }
            };
            
            reader.readAsText(file, 'UTF-8');
        }
        
        // Toggle manual input
        document.getElementById('manualInput').addEventListener('change', function() {
            const section = document.getElementById('manualInputSection');
            section.style.display = this.checked ? 'block' : 'none';
        });
        
        function addManualPage() {
            const title = document.getElementById('pageTitle').value;
            const url = document.getElementById('pageUrl').value;
            const description = document.getElementById('pageDescription').value;
            const category = document.getElementById('pageCategory').value;
            const tags = document.getElementById('pageTags').value.split(',').map(t => t.trim()).filter(t => t);
            
            if (!title || !url) {
                alert('Ÿäÿ±ÿ¨Ÿâ ÿ•ÿØÿÆÿßŸÑ ÿßŸÑÿπŸÜŸàÿßŸÜ ŸàÿßŸÑÿ±ÿßÿ®ÿ∑ ÿπŸÑŸâ ÿßŸÑÿ£ŸÇŸÑ');
                return;
            }
            
            manualPages.push({
                title,
                url: url.startsWith('/') ? url : '/' + url,
                description,
                category: category || 'ÿπÿßŸÖ',
                tags
            });
            
            // Clear inputs
            document.getElementById('pageTitle').value = '';
            document.getElementById('pageUrl').value = '';
            document.getElementById('pageDescription').value = '';
            document.getElementById('pageCategory').value = '';
            document.getElementById('pageTags').value = '';
            
            showNotification(`ÿ™ŸÖ ÿ•ÿ∂ÿßŸÅÿ©: ${title}`, 'success');
            autoSave();
        }
        
        function generateSearchIndex() {
            const urlInput = document.getElementById('urlInput').value.trim();
            const isManual = document.getElementById('manualInput').checked;
            
            // Don't reset searchIndex - append to existing data instead
            // searchIndex = []; // REMOVED: This was causing data loss
            
            // Find the highest existing ID to continue numbering
            let idCounter = searchIndex.length > 0 ? Math.max(...searchIndex.map(item => item.id)) + 1 : 1;
            
            // Track new items added in this session
            let newItemsCount = 0;
            
            // Add analyzed HTML files first
            if (analyzedFiles.length > 0) {
                analyzedFiles.forEach(file => {
                    // Check if this file is already in searchIndex
                    const existingItem = searchIndex.find(item => 
                        item.url === file.url || 
                        (item.source === 'html_analysis' && item.title === file.title)
                    );
                    
                    if (!existingItem) {
                        searchIndex.push({
                            id: idCounter++,
                            title: file.title,
                            description: file.description,
                            url: file.url,
                            category: 'ÿ™ÿ≠ŸÑŸäŸÑ ÿ™ŸÑŸÇÿßÿ¶Ÿä',
                            tags: file.keywords.length > 0 ? file.keywords : extractTagsFromUrl(file.url),
                            source: 'html_analysis',
                            content: file.content
                        });
                        newItemsCount++;
                    }
                });
            }
            
            if (isManual && manualPages.length > 0) {
                // Add manual pages
                manualPages.forEach(page => {
                    // Check if this manual page is already in searchIndex
                    const existingItem = searchIndex.find(item => 
                        item.url === page.url || 
                        (item.source === 'manual' && item.title === page.title)
                    );
                    
                    if (!existingItem) {
                        searchIndex.push({
                            id: idCounter++,
                            title: page.title,
                            description: page.description,
                            url: page.url,
                            category: page.category,
                            tags: page.tags,
                            source: 'manual'
                        });
                        newItemsCount++;
                    }
                });
            } else if (urlInput) {
                // Generate from URLs
                const urls = urlInput.split('\n').filter(url => url.trim());
                
                urls.forEach(url => {
                    url = url.trim();
                    if (!url) return;
                    
                    // Check if this URL already exists in searchIndex
                    const normalizedUrl = url.startsWith('/') ? url : '/' + url;
                    const existingItem = searchIndex.find(item => item.url === normalizedUrl);
                    
                    if (existingItem) {
                        // Skip if already exists
                        return;
                    }
                    
                    // Check if this URL was already analyzed from HTML file
                    const existingAnalysis = analyzedFiles.find(file => 
                        file.url === normalizedUrl || file.filename === url
                    );
                    
                    if (existingAnalysis) {
                        // Skip if already added from HTML analysis
                        return;
                    }
                    
                    // Extract info from URL
                    const fileName = url.split('/').pop().replace('.html', '');
                    const pathParts = url.split('/');
                    const category = pathParts.length > 1 ? pathParts[0] : 'ÿπÿßŸÖ';
                    
                    // Generate title from filename
                    let title = fileName.replace(/[-_]/g, ' ');
                    title = title.charAt(0).toUpperCase() + title.slice(1);
                    
                    // Special cases
                    if (fileName.toLowerCase() === 'index') title = 'ÿßŸÑÿµŸÅÿ≠ÿ© ÿßŸÑÿ±ÿ¶Ÿäÿ≥Ÿäÿ©';
                    if (fileName.toLowerCase() === 'about') title = 'ŸÖŸÜ ŸÜÿ≠ŸÜ';
                    if (fileName.toLowerCase() === 'contact') title = 'ÿßÿ™ÿµŸÑ ÿ®ŸÜÿß';
                    if (fileName.toLowerCase() === 'services') title = 'ÿÆÿØŸÖÿßÿ™ŸÜÿß';
                    if (fileName.toLowerCase() === 'blog') title = 'ÿßŸÑŸÖÿØŸàŸÜÿ©';
                    
                    // Enhanced tag extraction
                    const enhancedTags = extractTagsFromUrl(url);
                    
                    // Determine source
                    let source = 'url_generation';
                    if (sitemapUrls.includes(url)) source = 'sitemap';
                    if (robotsUrls.includes(url)) source = 'robots';
                    if (githubUrls.includes(url)) source = 'github';
                    
                    searchIndex.push({
                        id: idCounter++,
                        title: title,
                        description: `ÿµŸÅÿ≠ÿ© ${title} - ÿ™ÿ≠ÿ™ŸàŸä ÿπŸÑŸâ ŸÖÿπŸÑŸàŸÖÿßÿ™ ŸáÿßŸÖÿ© ÿ≠ŸàŸÑ ${title.toLowerCase()}`,
                        url: url.startsWith('/') ? url : '/' + url,
                        category: category.charAt(0).toUpperCase() + category.slice(1),
                        tags: enhancedTags.length > 0 ? enhancedTags : [fileName, category],
                        source: source
                    });
                    newItemsCount++;
                });
            }
            
            if (searchIndex.length === 0) {
                alert('Ÿäÿ±ÿ¨Ÿâ ÿ•ÿØÿÆÿßŸÑ ÿ±Ÿàÿßÿ®ÿ∑ ÿßŸÑÿµŸÅÿ≠ÿßÿ™ ÿ£Ÿà ÿ±ŸÅÿπ ŸÖŸÑŸÅÿßÿ™ HTML/Sitemap ÿ£Ÿà ÿßÿ≥ÿ™ÿÆÿØÿßŸÖ ÿßŸÑÿ•ÿØÿÆÿßŸÑ ÿßŸÑŸäÿØŸàŸä');
                return;
            }
            
            // Show notification about new items added
            if (newItemsCount > 0) {
                showNotification(`ÿ™ŸÖ ÿ•ÿ∂ÿßŸÅÿ© ${newItemsCount} ÿπŸÜÿµÿ± ÿ¨ÿØŸäÿØ! ÿ•ÿ¨ŸÖÿßŸÑŸä ÿßŸÑÿπŸÜÿßÿµÿ±: ${searchIndex.length}`, 'success');
            } else {
                showNotification('ŸÑÿß ÿ™Ÿàÿ¨ÿØ ÿπŸÜÿßÿµÿ± ÿ¨ÿØŸäÿØÿ© ŸÑŸÑÿ•ÿ∂ÿßŸÅÿ© - ÿ¨ŸÖŸäÿπ ÿßŸÑÿπŸÜÿßÿµÿ± ŸÖŸàÿ¨ŸàÿØÿ© ŸÖÿ≥ÿ®ŸÇÿßŸã', 'info');
            }
            
            displayResults();
            updateStatistics();
            updateLiveCounter();
            updateFilterOptions();
            document.getElementById('filterSection').style.display = 'block';
            autoSave();
        }
        
        function displayResults(resultsToShow = null) {
            const resultsDiv = document.getElementById('results');
            const results = resultsToShow || searchIndex;
            
            if (results.length === 0) {
                resultsDiv.innerHTML = '<p class="text-danger">ŸÑÿß ÿ™Ÿàÿ¨ÿØ ÿµŸÅÿ≠ÿßÿ™ ŸÑŸÑŸÖÿπÿßŸÑÿ¨ÿ©</p>';
                return;
            }
            
            let html = `<h5>ÿ™ŸÖ ÿ™ŸàŸÑŸäÿØ ${results.length} ÿπŸÜÿµÿ±:</h5>`;
            
            // Group by source
            const grouped = results.reduce((acc, item) => {
                const source = item.source || 'unknown';
                if (!acc[source]) acc[source] = [];
                acc[source].push(item);
                return acc;
            }, {});
            
            Object.keys(grouped).forEach(source => {
                const sourceLabel = {
                    'html_analysis': 'üìÑ ÿ™ÿ≠ŸÑŸäŸÑ ŸÖŸÑŸÅÿßÿ™ HTML',
                    'manual': '‚úèÔ∏è ÿ•ÿØÿÆÿßŸÑ ŸäÿØŸàŸä',
                    'url_generation': 'üîó ÿ™ŸàŸÑŸäÿØ ŸÖŸÜ ÿßŸÑÿ±Ÿàÿßÿ®ÿ∑',
                    'sitemap': 'üó∫Ô∏è ŸÖŸÜ Sitemap.xml',
                    'robots': 'ü§ñ ŸÖŸÜ robots.txt',
                    'github': 'üêô ŸÖŸÜ GitHub Pages'
                }[source] || source;
                
                html += `<h6 class="mt-3 text-primary">${sourceLabel} (${grouped[source].length})</h6>`;
                
                grouped[source].forEach(item => {
                    html += `
                    <div class="page-item" data-id="${item.id}">
                        <button class="btn btn-outline-secondary btn-sm edit-btn" onclick="toggleEdit(${item.id})">ÿ™ÿ≠ÿ±Ÿäÿ±</button>
                        <div class="page-title editable-content" data-field="title" contenteditable="false">${item.title}</div>
                        <div class="page-url">${item.url}</div>
                        <div class="text-muted editable-content" data-field="description" contenteditable="false">${item.description}</div>
                        <div class="mt-2">
                            <small class="text-info">ÿßŸÑŸÅÿ¶ÿ©: <span class="editable-content" data-field="category" contenteditable="false">${item.category}</span></small>
                        </div>
                        <div class="mt-1">
                            <small class="text-success">ÿßŸÑŸÉŸÑŸÖÿßÿ™: <span class="editable-content" data-field="tags" contenteditable="false">${item.tags.join(', ')}</span></small>
                        </div>
                    </div>
                    `;
                });
            });
            
            resultsDiv.innerHTML = html;
            
            // Show export buttons
            document.getElementById('exportButtons').style.display = 'flex';
        }
        
        function toggleEdit(itemId) {
            const pageItem = document.querySelector(`[data-id="${itemId}"]`);
            const editableElements = pageItem.querySelectorAll('.editable-content');
            const editBtn = pageItem.querySelector('.edit-btn');
            
            const isEditing = editableElements[0].getAttribute('contenteditable') === 'true';
            
            if (isEditing) {
                // Save changes
                editableElements.forEach(element => {
                    element.setAttribute('contenteditable', 'false');
                    element.style.backgroundColor = '';
                    
                    const field = element.getAttribute('data-field');
                    const value = element.textContent.trim();
                    
                    // Update searchIndex
                    const item = searchIndex.find(item => item.id === itemId);
                    if (item) {
                        if (field === 'tags') {
                            item[field] = value.split(',').map(t => t.trim()).filter(t => t);
                        } else {
                            item[field] = value;
                        }
                    }
                });
                
                editBtn.textContent = 'ÿ™ÿ≠ÿ±Ÿäÿ±';
                editBtn.className = 'btn btn-outline-secondary btn-sm edit-btn';
                showNotification('ÿ™ŸÖ ÿ≠ŸÅÿ∏ ÿßŸÑÿ™ÿπÿØŸäŸÑÿßÿ™! ‚úÖ', 'success');
                updateStatistics();
                autoSave();
            } else {
                // Enable editing
                editableElements.forEach(element => {
                    element.setAttribute('contenteditable', 'true');
                    element.style.backgroundColor = '#fff3cd';
                });
                
                editBtn.textContent = 'ÿ≠ŸÅÿ∏';
                editBtn.className = 'btn btn-success btn-sm edit-btn';
            }
        }
        
        // Enhanced export functions
        function downloadJson() {
            const jsonData = JSON.stringify(searchIndex.map(item => ({
                id: item.id,
                title: item.title,
                description: item.description,
                url: item.url,
                category: item.category,
                tags: item.tags
            })), null, 2);
            
            const blob = new Blob([jsonData], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            
            const a = document.createElement('a');
            a.href = url;
            a.download = 'search-index.json';
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
            
            showNotification('ÿ™ŸÖ ÿ™ÿ≠ŸÖŸäŸÑ search-index.json ÿ®ŸÜÿ¨ÿßÿ≠! ‚úÖ', 'success');
        }
        
        function downloadCSV() {
            const headers = ['ID', 'ÿßŸÑÿπŸÜŸàÿßŸÜ', 'ÿßŸÑÿ±ÿßÿ®ÿ∑', 'ÿßŸÑŸàÿµŸÅ', 'ÿßŸÑŸÅÿ¶ÿ©', 'ÿßŸÑŸÉŸÑŸÖÿßÿ™ ÿßŸÑŸÖŸÅÿ™ÿßÿ≠Ÿäÿ©'];
            const csvContent = [
                headers.join(','),
                ...searchIndex.map(item => [
                    item.id,
                    `"${item.title.replace(/"/g, '""')}"`,
                    `"${item.url}"`,
                    `"${item.description.replace(/"/g, '""')}"`,
                    `"${item.category}"`,
                    `"${item.tags.join(', ').replace(/"/g, '""')}"`
                ].join(','))
            ].join('\n');
            
            // Add BOM for proper Arabic display in Excel
            const blob = new Blob(['\ufeff' + csvContent], { type: 'text/csv;charset=utf-8;' });
            const url = URL.createObjectURL(blob);
            
            const a = document.createElement('a');
            a.href = url;
            a.download = 'search-index.csv';
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
            
            showNotification('ÿ™ŸÖ ÿ™ÿ≠ŸÖŸäŸÑ search-index.csv ÿ®ŸÜÿ¨ÿßÿ≠! üìä', 'success');
        }
        
        async function downloadZip() {
            const zipProgress = document.getElementById('zipProgress');
            const zipProgressBar = document.getElementById('zipProgressBar');
            const zipProgressText = document.getElementById('zipProgressText');
            
            zipProgress.style.display = 'block';
            zipProgressBar.style.width = '10%';
            zipProgressText.textContent = 'ÿ¨ÿßÿ±Ÿä ÿ•ŸÜÿ¥ÿßÿ° ŸÖŸÑŸÅ ZIP...';
            
            try {
                const zip = new JSZip();
                
                // Add search-index.json
                const jsonData = JSON.stringify(searchIndex.map(item => ({
                    id: item.id,
                    title: item.title,
                    description: item.description,
                    url: item.url,
                    category: item.category,
                    tags: item.tags
                })), null, 2);
                
                zip.file('search-index.json', jsonData);
                zipProgressBar.style.width = '30%';
                zipProgressText.textContent = 'ÿ™ŸÖ ÿ•ÿ∂ÿßŸÅÿ© search-index.json...';
                
                // Add HTML files if available
                const htmlFiles = analyzedFiles.filter(file => file.content);
                if (htmlFiles.length > 0) {
                    const htmlFolder = zip.folder('html-files');
                    
                    for (let i = 0; i < htmlFiles.length; i++) {
                        const file = htmlFiles[i];
                        htmlFolder.file(file.filename, file.content);
                        
                        const progress = 30 + (i + 1) / htmlFiles.length * 50;
                        zipProgressBar.style.width = progress + '%';
                        zipProgressText.textContent = `ÿ™ŸÖ ÿ•ÿ∂ÿßŸÅÿ© ${file.filename}...`;
                        
                        // Small delay for UI responsiveness
                        await new Promise(resolve => setTimeout(resolve, 50));
                    }
                }
                
                zipProgressBar.style.width = '90%';
                zipProgressText.textContent = 'ÿ¨ÿßÿ±Ÿä ÿ∂ÿ∫ÿ∑ ÿßŸÑŸÖŸÑŸÅÿßÿ™...';
                
                // Generate ZIP file
                const content = await zip.generateAsync({type: 'blob'});
                
                zipProgressBar.style.width = '100%';
                zipProgressText.textContent = 'ÿ™ŸÖ ÿ•ŸÜÿ¥ÿßÿ° ÿßŸÑŸÖŸÑŸÅ ÿ®ŸÜÿ¨ÿßÿ≠!';
                
                // Download ZIP
                const url = URL.createObjectURL(content);
                const a = document.createElement('a');
                a.href = url;
                a.download = 'search-index-package.zip';
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
                
                showNotification('ÿ™ŸÖ ÿ™ÿ≠ŸÖŸäŸÑ ÿßŸÑÿ≠ÿ≤ŸÖÿ© ÿßŸÑŸÉÿßŸÖŸÑÿ© ÿ®ŸÜÿ¨ÿßÿ≠! üì¶', 'success');
                
                setTimeout(() => {
                    zipProgress.style.display = 'none';
                }, 2000);
                
            } catch (error) {
                showNotification('ÿÆÿ∑ÿ£ ŸÅŸä ÿ•ŸÜÿ¥ÿßÿ° ŸÖŸÑŸÅ ZIP: ' + error.message, 'danger');
                zipProgress.style.display = 'none';
            }
        }
        
        function toggleCopyOptions() {
            const copyOptions = document.getElementById('copyOptions');
            copyOptions.style.display = copyOptions.style.display === 'none' ? 'block' : 'none';
        }
        
        function copyToClipboard(type) {
            let content = '';
            
            switch (type) {
                case 'all':
                    content = JSON.stringify(searchIndex.map(item => ({
                        id: item.id,
                        title: item.title,
                        description: item.description,
                        url: item.url,
                        category: item.category,
                        tags: item.tags
                    })), null, 2);
                    break;
                case 'titles':
                    content = searchIndex.map(item => item.title).join('\n');
                    break;
                case 'urls':
                    content = searchIndex.map(item => item.url).join('\n');
                    break;
                case 'descriptions':
                    content = searchIndex.map(item => item.description).join('\n');
                    break;
            }
            
            navigator.clipboard.writeText(content).then(() => {
                const typeLabels = {
                    'all': 'ÿßŸÑÿ®ŸäÿßŸÜÿßÿ™ ÿßŸÑŸÉÿßŸÖŸÑÿ©',
                    'titles': 'ÿßŸÑÿπŸÜÿßŸàŸäŸÜ',
                    'urls': 'ÿßŸÑÿ±Ÿàÿßÿ®ÿ∑',
                    'descriptions': 'ÿßŸÑÿ£ŸàÿµÿßŸÅ'
                };
                showNotification(`ÿ™ŸÖ ŸÜÿ≥ÿÆ ${typeLabels[type]} ÿ•ŸÑŸâ ÿßŸÑÿ≠ÿßŸÅÿ∏ÿ©! üìã`, 'success');
                toggleCopyOptions();
            }).catch(err => {
                console.error('ÿÆÿ∑ÿ£ ŸÅŸä ÿßŸÑŸÜÿ≥ÿÆ:', err);
                // Fallback
                const textArea = document.createElement('textarea');
                textArea.value = content;
                document.body.appendChild(textArea);
                textArea.select();
                document.execCommand('copy');
                document.body.removeChild(textArea);
                showNotification('ÿ™ŸÖ ŸÜÿ≥ÿÆ ÿßŸÑÿ®ŸäÿßŸÜÿßÿ™ ÿ•ŸÑŸâ ÿßŸÑÿ≠ÿßŸÅÿ∏ÿ©! üìã', 'success');
                toggleCopyOptions();
            });
        }
        
        // Auto-save when URL input changes
        document.getElementById('urlInput').addEventListener('input', autoSave);
    </script>
</body>
</html>