<!DOCTYPE html>
<html lang="ar" dir="rtl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Ù…ÙˆÙ„Ø¯ ÙÙ‡Ø±Ø³ Ø§Ù„Ø¨Ø­Ø« Ø§Ù„Ù…ØªØ·ÙˆØ± - Ultimate Edition</title>
    <link href="https://cdnjs.cloudflare.com/ajax/libs/bootstrap/5.3.0/css/bootstrap.min.css" rel="stylesheet">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
    <style>
        :root {
            --bg-primary: #ffffff;
            --bg-secondary: #f8f9fa;
            --text-primary: #212529;
            --text-secondary: #6c757d;
            --border-color: #dee2e6;
            --card-bg: #ffffff;
            --input-bg: #ffffff;
            --accent-color: #0d6efd;
        }

        [data-theme="dark"] {
            --bg-primary: #1a1a1a;
            --bg-secondary: #2d2d2d;
            --text-primary: #ffffff;
            --text-secondary: #b0b0b0;
            --border-color: #404040;
            --card-bg: #2d2d2d;
            --input-bg: #3d3d3d;
            --accent-color: #4dabf7;
        }

        body {
            background-color: var(--bg-primary);
            color: var(--text-primary);
            transition: all 0.3s ease;
        }

        .card {
            background-color: var(--card-bg);
            border-color: var(--border-color);
        }

        .form-control, .form-select {
            background-color: var(--input-bg);
            border-color: var(--border-color);
            color: var(--text-primary);
        }

        .form-control:focus, .form-select:focus {
            background-color: var(--input-bg);
            border-color: var(--accent-color);
            color: var(--text-primary);
        }

        .result-box {
            background: var(--bg-secondary);
            border: 1px solid var(--border-color);
            border-radius: 8px;
            padding: 20px;
            margin: 20px 0;
            max-height: 500px;
            overflow-y: auto;
        }
        
        .page-item {
            border: 1px solid var(--border-color);
            border-radius: 6px;
            padding: 15px;
            margin: 10px 0;
            background: var(--card-bg);
            position: relative;
            transition: all 0.3s ease;
        }

        .page-item:hover {
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
        }
        
        .page-title {
            color: var(--accent-color);
            font-weight: bold;
            margin-bottom: 5px;
        }
        
        .page-url {
            color: var(--text-secondary);
            font-size: 0.9em;
        }
        
        .file-drop-zone {
            border: 2px dashed var(--border-color);
            border-radius: 8px;
            padding: 30px;
            text-align: center;
            margin: 15px 0;
            transition: all 0.3s ease;
            cursor: pointer;
            background: var(--bg-secondary);
        }
        
        .file-drop-zone:hover {
            border-color: var(--accent-color);
            background-color: rgba(13, 110, 253, 0.1);
        }
        
        .file-drop-zone.dragover {
            border-color: var(--accent-color);
            background-color: rgba(13, 110, 253, 0.2);
        }

        .url-textarea-container {
            position: relative;
        }

        .url-textarea-drop {
            border: 2px dashed transparent;
            transition: all 0.3s ease;
        }

        .url-textarea-drop.dragover {
            border-color: #28a745;
            background-color: rgba(40, 167, 69, 0.1);
        }
        
        .progress-container {
            display: none;
            margin: 15px 0;
        }
        
        .feature-badge {
            background: linear-gradient(45deg, #28a745, #20c997);
            color: white;
            padding: 2px 8px;
            border-radius: 12px;
            font-size: 0.8em;
            margin-left: 5px;
        }

        .pro-badge {
            background: linear-gradient(45deg, #6f42c1, #e83e8c);
            color: white;
            padding: 2px 8px;
            border-radius: 12px;
            font-size: 0.8em;
            margin-left: 5px;
        }

        .ultimate-badge {
            background: linear-gradient(45deg, #fd7e14, #dc3545);
            color: white;
            padding: 2px 8px;
            border-radius: 12px;
            font-size: 0.8em;
            margin-left: 5px;
            animation: pulse 2s infinite;
        }

        @keyframes pulse {
            0% { transform: scale(1); }
            50% { transform: scale(1.05); }
            100% { transform: scale(1); }
        }
        
        .edit-btn {
            position: absolute;
            top: 10px;
            left: 10px;
            padding: 2px 6px;
            font-size: 0.7em;
        }
        
        .editable-content {
            border: 1px dashed #ccc;
            padding: 5px;
            border-radius: 4px;
            cursor: text;
        }
        
        .editable-content:focus {
            outline: 2px solid var(--accent-color);
            background-color: var(--input-bg);
        }
        
        .sitemap-section {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border-radius: 8px;
            padding: 20px;
            margin: 15px 0;
        }
        
        .robots-section {
            background: linear-gradient(135deg, #ff9a9e 0%, #fecfef 100%);
            color: #333;
            border-radius: 8px;
            padding: 20px;
            margin: 15px 0;
        }

        .manifest-section {
            background: linear-gradient(135deg, #a8edea 0%, #fed6e3 100%);
            color: #333;
            border-radius: 8px;
            padding: 20px;
            margin: 15px 0;
        }

        .github-section {
            background: linear-gradient(135deg, #d299c2 0%, #fef9d7 100%);
            color: #333;
            border-radius: 8px;
            padding: 20px;
            margin: 15px 0;
        }
        
        .drop-zone {
            border: 2px dashed rgba(255,255,255,0.5);
            border-radius: 8px;
            padding: 20px;
            text-align: center;
            cursor: pointer;
            transition: all 0.3s ease;
        }
        
        .drop-zone:hover {
            border-color: white;
            background-color: rgba(255,255,255,0.1);
        }

        .dark-mode-toggle {
            position: fixed;
            top: 20px;
            left: 20px;
            z-index: 1000;
            border-radius: 50px;
            padding: 8px 16px;
            border: none;
            background: linear-gradient(45deg, #667eea, #764ba2);
            color: white;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .dark-mode-toggle:hover {
            transform: scale(1.05);
            box-shadow: 0 4px 15px rgba(0,0,0,0.2);
        }

        .export-buttons {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
            margin-top: 15px;
        }

        .export-buttons .btn {
            flex: 1;
            min-width: 120px;
        }

        .copy-options {
            display: none;
            margin-top: 10px;
            padding: 15px;
            background: var(--bg-secondary);
            border-radius: 8px;
            border: 1px solid var(--border-color);
        }

        .zip-progress {
            display: none;
            margin-top: 10px;
        }

        .stats-panel {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border-radius: 8px;
            padding: 20px;
            margin: 15px 0;
        }

        .stat-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 8px 0;
            border-bottom: 1px solid rgba(255,255,255,0.2);
        }

        .stat-item:last-child {
            border-bottom: none;
        }

        .live-counter {
            position: fixed;
            top: 80px;
            left: 20px;
            z-index: 999;
            background: linear-gradient(45deg, #28a745, #20c997);
            color: white;
            padding: 8px 16px;
            border-radius: 20px;
            font-weight: bold;
            box-shadow: 0 2px 10px rgba(0,0,0,0.2);
            transition: all 0.3s ease;
        }

        .filter-section {
            background: var(--bg-secondary);
            border: 1px solid var(--border-color);
            border-radius: 8px;
            padding: 15px;
            margin: 15px 0;
        }

        .hidden {
            display: none !important;
        }

        @media (max-width: 768px) {
            .export-buttons {
                flex-direction: column;
            }
            
            .export-buttons .btn {
                width: 100%;
                margin-bottom: 5px;
            }

            .live-counter {
                position: relative;
                top: auto;
                left: auto;
                margin: 10px 0;
                display: inline-block;
            }
        }
    </style>
</head>
<body>
    <button class="dark-mode-toggle" onclick="toggleDarkMode()">
        ğŸŒ™ Ø§Ù„ÙˆØ¶Ø¹ Ø§Ù„Ù„ÙŠÙ„ÙŠ
    </button>

    <div class="live-counter" id="liveCounter" style="display: none;">
        ğŸ“Š Ø§Ù„Ø¹Ù†Ø§ØµØ±: <span id="counterValue">0</span>
    </div>

    <div class="container mt-5">
        <h1 class="text-center mb-5">ğŸ” Ù…ÙˆÙ„Ø¯ ÙÙ‡Ø±Ø³ Ø§Ù„Ø¨Ø­Ø« Ø§Ù„Ù…ØªØ·ÙˆØ± <span class="ultimate-badge">Ultimate</span></h1>
        
        <div class="row">
            <div class="col-md-6">
                <div class="card">
                    <div class="card-header">
                        <h3>ğŸ“ Ø¥Ø¯Ø®Ø§Ù„ ØµÙØ­Ø§Øª Ø§Ù„Ù…ÙˆÙ‚Ø¹</h3>
                    </div>
                    <div class="card-body">
                        <!-- GitHub Pages Section -->
                        <div class="github-section">
                            <h5>ğŸ™ Ø§Ø³ØªÙŠØ±Ø§Ø¯ Ù…Ù† GitHub Pages <span class="feature-badge">Ø¬Ø¯ÙŠØ¯</span></h5>
                            <div class="row">
                                <div class="col-8">
                                    <input type="url" class="form-control" id="githubUrl" placeholder="https://username.github.io/repository">
                                </div>
                                <div class="col-4">
                                    <button class="btn btn-outline-dark w-100" onclick="fetchFromGitHub()">
                                        ğŸš€ Ø¬Ù„Ø¨
                                    </button>
                                </div>
                            </div>
                            <small class="d-block mt-2">Ø³ÙŠØªÙ… Ø¬Ù„Ø¨ ÙˆØªØ­Ù„ÙŠÙ„ Ø¬Ù…ÙŠØ¹ ØµÙØ­Ø§Øª HTML Ù…Ù† Ø§Ù„Ù…ÙˆÙ‚Ø¹ ØªÙ„Ù‚Ø§Ø¦ÙŠØ§Ù‹</small>
                        </div>

                        <!-- Robots.txt Section -->
                        <div class="robots-section">
                            <h5>ğŸ¤– Ø§Ø³ØªÙŠØ±Ø§Ø¯ Ù…Ù† robots.txt <span class="feature-badge">Ø¬Ø¯ÙŠØ¯</span></h5>
                            <div class="drop-zone" id="robotsDropZone">
                                <i class="fas fa-robot fa-2x mb-2"></i>
                                <p class="mb-2">Ø§Ø³Ø­Ø¨ ÙˆØ£ÙÙ„Øª Ù…Ù„Ù robots.txt Ù‡Ù†Ø§ Ø£Ùˆ Ø§Ù†Ù‚Ø± Ù„Ù„Ø§Ø®ØªÙŠØ§Ø±</p>
                                <small>Ø³ÙŠØªÙ… Ø§Ø³ØªØ®Ø±Ø§Ø¬ Ø§Ù„ØµÙØ­Ø§Øª Ø§Ù„Ù…Ø³ØªØ¨Ø¹Ø¯Ø© ÙˆØ§Ù„Ù…Ø³Ù…ÙˆØ­Ø©</small>
                                <input type="file" id="robotsFileInput" accept=".txt" style="display: none;">
                            </div>
                        </div>

                        <!-- Manifest.json Section -->
                        <div class="manifest-section">
                            <h5>ğŸ“± Ø§Ø³ØªÙŠØ±Ø§Ø¯ Ù…Ù† manifest.json <span class="feature-badge">PWA</span></h5>
                            <div class="drop-zone" id="manifestDropZone">
                                <i class="fas fa-mobile-alt fa-2x mb-2"></i>
                                <p class="mb-2">Ø§Ø³Ø­Ø¨ ÙˆØ£ÙÙ„Øª Ù…Ù„Ù manifest.json Ù‡Ù†Ø§ Ø£Ùˆ Ø§Ù†Ù‚Ø± Ù„Ù„Ø§Ø®ØªÙŠØ§Ø±</p>
                                <small>Ø³ÙŠØªÙ… Ø§Ø³ØªØ®Ø±Ø§Ø¬ Ø£Ø³Ù…Ø§Ø¡ Ø§Ù„Ø£Ù‚Ø³Ø§Ù… Ù…Ù† ØªØ·Ø¨ÙŠÙ‚ PWA</small>
                                <input type="file" id="manifestFileInput" accept=".json" style="display: none;">
                            </div>
                        </div>

                        <!-- Sitemap.xml Section -->
                        <div class="sitemap-section">
                            <h5>ğŸ—ºï¸ Ø§Ø³ØªÙŠØ±Ø§Ø¯ Ù…Ù† Sitemap.xml <span class="feature-badge">Ø°ÙƒÙŠ</span></h5>
                            <div class="drop-zone" id="sitemapDropZone">
                                <i class="fas fa-sitemap fa-2x mb-2"></i>
                                <p class="mb-2">Ø§Ø³Ø­Ø¨ ÙˆØ£ÙÙ„Øª Ù…Ù„Ù sitemap.xml Ù‡Ù†Ø§ Ø£Ùˆ Ø§Ù†Ù‚Ø± Ù„Ù„Ø§Ø®ØªÙŠØ§Ø±</p>
                                <small>Ø³ÙŠØªÙ… Ø§Ø³ØªØ®Ø±Ø§Ø¬ Ø¬Ù…ÙŠØ¹ Ø§Ù„Ø±ÙˆØ§Ø¨Ø· ØªÙ„Ù‚Ø§Ø¦ÙŠØ§Ù‹ Ù…Ù† Ø®Ø±ÙŠØ·Ø© Ø§Ù„Ù…ÙˆÙ‚Ø¹</small>
                                <input type="file" id="sitemapFileInput" accept=".xml" style="display: none;">
                            </div>
                        </div>

                        <!-- HTML File Analysis Section -->
                        <div class="mb-4">
                            <label class="form-label">
                                ğŸ“„ ØªØ­Ù„ÙŠÙ„ Ù…Ù„ÙØ§Øª HTML ØªÙ„Ù‚Ø§Ø¦ÙŠÙ‹Ø§ <span class="feature-badge">Ù…Ø­Ø³Ù†</span>
                            </label>
                            <div class="file-drop-zone" id="fileDropZone">
                                <i class="fas fa-cloud-upload-alt fa-2x text-muted mb-2"></i>
                                <p class="mb-2">Ø§Ø³Ø­Ø¨ ÙˆØ£ÙÙ„Øª Ù…Ù„ÙØ§Øª HTML Ù‡Ù†Ø§ Ø£Ùˆ Ø§Ù†Ù‚Ø± Ù„Ù„Ø§Ø®ØªÙŠØ§Ø±</p>
                                <small class="text-muted">Ø³ÙŠØªÙ… Ø§Ø³ØªØ®Ø±Ø§Ø¬ Ø§Ù„Ø¹Ù†ÙˆØ§Ù† ÙˆØ§Ù„ÙˆØµÙ ØªÙ„Ù‚Ø§Ø¦ÙŠÙ‹Ø§ Ù…Ù† ÙƒÙ„ Ù…Ù„Ù</small>
                                <input type="file" id="htmlFileInput" multiple accept=".html,.htm" style="display: none;">
                            </div>
                            <div class="progress-container" id="progressContainer">
                                <div class="progress">
                                    <div class="progress-bar" id="progressBar" role="progressbar" style="width: 0%"></div>
                                </div>
                                <small class="text-muted" id="progressText">Ø¬Ø§Ø±ÙŠ Ø§Ù„Ù…Ø¹Ø§Ù„Ø¬Ø©...</small>
                            </div>
                        </div>

                        <!-- Bulk Import Section -->
                        <div class="mb-4">
                            <label class="form-label">
                                ğŸ“‚ Ø§Ø³ØªÙŠØ±Ø§Ø¯ Ø¬Ù…Ø§Ø¹ÙŠ <span class="feature-badge">Ù…Ø­Ø³Ù†</span>
                            </label>
                            <div class="row">
                                <div class="col-6">
                                    <input type="file" class="form-control" id="urlsFileInput" accept=".txt,.json">
                                    <small class="text-muted">Ù…Ù„Ù .txt Ø£Ùˆ .json</small>
                                </div>
                                <div class="col-6">
                                    <button class="btn btn-outline-primary w-100" onclick="importUrlsFile()">
                                        ğŸ“¥ Ø§Ø³ØªÙŠØ±Ø§Ø¯ Ø§Ù„Ø±ÙˆØ§Ø¨Ø·
                                    </button>
                                </div>
                            </div>
                        </div>
                        
                        <div class="mb-3">
                            <label class="form-label">
                                Ø±ÙˆØ§Ø¨Ø· ØµÙØ­Ø§Øª Ù…ÙˆÙ‚Ø¹Ùƒ <span class="pro-badge">Drag & Drop</span>
                            </label>
                            <div class="url-textarea-container">
                                <textarea class="form-control url-textarea-drop" id="urlInput" rows="6" 
                                    placeholder="index.html
about.html
services.html
contact.html
blog/article1.html
blog/article2.html

ğŸ’¡ ÙŠÙ…ÙƒÙ†Ùƒ Ø³Ø­Ø¨ ÙˆØ¥ÙÙ„Ø§Øª Ù…Ù„ÙØ§Øª Ø§Ù„Ù†ØµÙˆØµ Ù‡Ù†Ø§ Ù…Ø¨Ø§Ø´Ø±Ø©!"></textarea>
                            </div>
                        </div>
                        
                        <div class="mb-3">
                            <label class="form-label">Ø£Ùˆ Ø£Ø¯Ø®Ù„ Ù‚Ø§Ø¦Ù…Ø© ÙŠØ¯ÙˆÙŠØ©:</label>
                            <div class="form-check">
                                <input class="form-check-input" type="checkbox" id="manualInput">
                                <label class="form-check-label" for="manualInput">
                                    Ø¥Ø¯Ø®Ø§Ù„ ÙŠØ¯ÙˆÙŠ Ù„Ù„ØµÙØ­Ø§Øª
                                </label>
                            </div>
                        </div>
                        
                        <div id="manualInputSection" style="display: none;">
                            <div class="mb-3">
                                <input type="text" class="form-control mb-2" id="pageTitle" placeholder="Ø¹Ù†ÙˆØ§Ù† Ø§Ù„ØµÙØ­Ø©">
                                <input type="text" class="form-control mb-2" id="pageUrl" placeholder="Ø±Ø§Ø¨Ø· Ø§Ù„ØµÙØ­Ø©">
                                <input type="text" class="form-control mb-2" id="pageDescription" placeholder="ÙˆØµÙ Ø§Ù„ØµÙØ­Ø©">
                                <input type="text" class="form-control mb-2" id="pageCategory" placeholder="ÙØ¦Ø© Ø§Ù„ØµÙØ­Ø©">
                                <input type="text" class="form-control mb-2" id="pageTags" placeholder="Ø§Ù„ÙƒÙ„Ù…Ø§Øª Ø§Ù„Ù…ÙØªØ§Ø­ÙŠØ© (Ù…ÙØµÙˆÙ„Ø© Ø¨ÙÙˆØ§ØµÙ„)">
                                <button class="btn btn-success btn-sm" onclick="addManualPage()">Ø¥Ø¶Ø§ÙØ© ØµÙØ­Ø©</button>
                            </div>
                        </div>
                        
                        <button class="btn btn-primary w-100" onclick="generateSearchIndex()">
                            ğŸš€ ØªÙˆÙ„ÙŠØ¯ ÙÙ‡Ø±Ø³ Ø§Ù„Ø¨Ø­Ø«
                        </button>
                        
                        <!-- Data Management -->
                        <div class="mt-3">
                            <div class="row">
                                <div class="col-4">
                                    <button class="btn btn-outline-success w-100 btn-sm" onclick="saveToLocalStorage()">
                                        ğŸ’¾ Ø­ÙØ¸
                                    </button>
                                </div>
                                <div class="col-4">
                                    <button class="btn btn-outline-info w-100 btn-sm" onclick="loadFromLocalStorage()">
                                        ğŸ“‚ ØªØ­Ù…ÙŠÙ„
                                    </button>
                                </div>
                                <div class="col-4">
                                    <button class="btn btn-outline-danger w-100 btn-sm" onclick="deleteAllData()">
                                        ğŸ—‘ï¸ Ø­Ø°Ù Ø§Ù„ÙƒÙ„
                                    </button>
                                </div>
                            </div>
                            <small class="text-muted d-block mt-1">Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª Ù…Ø­ÙÙˆØ¸Ø© Ù…Ø­Ù„ÙŠÙ‹Ø§ ÙÙŠ Ø§Ù„Ù…ØªØµÙØ­</small>
                        </div>
                    </div>
                </div>
            </div>
            
            <div class="col-md-6">
                <div class="card">
                    <div class="card-header">
                        <h3>ğŸ“Š Ø§Ù„Ù†ØªØ§Ø¦Ø¬ <span class="pro-badge">Ù‚Ø§Ø¨Ù„ Ù„Ù„ØªØ­Ø±ÙŠØ±</span></h3>
                    </div>
                    <div class="card-body">
                        <!-- Statistics Panel -->
                        <div class="stats-panel" id="statsPanel" style="display: none;">
                            <h6>ğŸ“ˆ Ø¥Ø­ØµØ§Ø¦ÙŠØ§Øª Ø¯Ø§Ø®Ù„ÙŠØ©</h6>
                            <div class="stat-item">
                                <span>Ø¹Ø¯Ø¯ Ø§Ù„ØµÙØ­Ø§Øª:</span>
                                <strong id="statPages">0</strong>
                            </div>
                            <div class="stat-item">
                                <span>Ø¥Ø¬Ù…Ø§Ù„ÙŠ Ø§Ù„ÙƒÙ„Ù…Ø§Øª Ø§Ù„Ù…ÙØªØ§Ø­ÙŠØ©:</span>
                                <strong id="statKeywords">0</strong>
                            </div>
                            <div class="stat-item">
                                <span>Ø§Ù„ÙØ¦Ø§Øª Ø§Ù„Ù…Ø®ØªÙ„ÙØ©:</span>
                                <strong id="statCategories">0</strong>
                            </div>
                            <div class="stat-item">
                                <span>Ø£ÙƒØ«Ø± Ø§Ù„ÙƒÙ„Ù…Ø§Øª ØªÙƒØ±Ø§Ø±Ø§Ù‹:</span>
                                <strong id="statTopKeyword">-</strong>
                            </div>
                        </div>

                        <!-- Filter Section -->
                        <div class="filter-section" id="filterSection" style="display: none;">
                            <h6>ğŸ” ØªØµÙÙŠØ© Ø§Ù„Ù†ØªØ§Ø¦Ø¬</h6>
                            <div class="row">
                                <div class="col-6">
                                    <select class="form-select form-select-sm" id="categoryFilter">
                                        <option value="">Ø¬Ù…ÙŠØ¹ Ø§Ù„ÙØ¦Ø§Øª</option>
                                    </select>
                                </div>
                                <div class="col-6">
                                    <input type="text" class="form-control form-control-sm" id="keywordFilter" placeholder="Ø¨Ø­Ø« Ø¨Ø§Ù„ÙƒÙ„Ù…Ø© Ø§Ù„Ù…ÙØªØ§Ø­ÙŠØ©">
                                </div>
                            </div>
                        </div>

                        <div id="results" class="result-box">
                            <p class="text-muted text-center">Ø£Ø¯Ø®Ù„ Ø±ÙˆØ§Ø¨Ø· Ø§Ù„ØµÙØ­Ø§Øª Ø£Ùˆ Ø§Ø±ÙØ¹ Ù…Ù„ÙØ§Øª HTML/Sitemap ÙˆØ§Ø¶ØºØ· "ØªÙˆÙ„ÙŠØ¯ ÙÙ‡Ø±Ø³ Ø§Ù„Ø¨Ø­Ø«"</p>
                        </div>
                        
                        <!-- Enhanced Export Options -->
                        <div class="export-buttons" id="exportButtons" style="display: none;">
                            <button class="btn btn-success" onclick="downloadJson()">
                                ğŸ’¾ JSON
                            </button>
                            
                            <button class="btn btn-info" onclick="downloadCSV()">
                                ğŸ“Š CSV
                            </button>
                            
                            <button class="btn btn-warning" onclick="downloadZip()">
                                ğŸ“¦ ZIP
                            </button>
                            
                            <button class="btn btn-secondary" onclick="toggleCopyOptions()">
                                ğŸ“‹ Ù†Ø³Ø®
                            </button>
                        </div>

                        <!-- ZIP Progress -->
                        <div class="zip-progress" id="zipProgress">
                            <div class="progress">
                                <div class="progress-bar progress-bar-striped progress-bar-animated" id="zipProgressBar" role="progressbar" style="width: 0%"></div>
                            </div>
                            <small class="text-muted" id="zipProgressText">Ø¬Ø§Ø±ÙŠ Ø¥Ù†Ø´Ø§Ø¡ Ù…Ù„Ù ZIP...</small>
                        </div>

                        <!-- Copy Options -->
                        <div class="copy-options" id="copyOptions">
                            <h6>Ø®ÙŠØ§Ø±Ø§Øª Ø§Ù„Ù†Ø³Ø®:</h6>
                            <div class="d-grid gap-2">
                                <button class="btn btn-outline-primary btn-sm" onclick="copyToClipboard('all')">
                                    ğŸ“‹ Ù†Ø³Ø® ÙƒØ§Ù…Ù„ (JSON)
                                </button>
                                <button class="btn btn-outline-secondary btn-sm" onclick="copyToClipboard('titles')">
                                    ğŸ“ Ù†Ø³Ø® Ø§Ù„Ø¹Ù†Ø§ÙˆÙŠÙ† ÙÙ‚Ø·
                                </button>
                                <button class="btn btn-outline-info btn-sm" onclick="copyToClipboard('urls')">
                                    ğŸ”— Ù†Ø³Ø® Ø§Ù„Ø±ÙˆØ§Ø¨Ø· ÙÙ‚Ø·
                                </button>
                                <button class="btn btn-outline-success btn-sm" onclick="copyToClipboard('descriptions')">
                                    ğŸ“„ Ù†Ø³Ø® Ø§Ù„Ø£ÙˆØµØ§Ù ÙÙ‚Ø·
                                </button>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
        
        <div class="row mt-5">
            <div class="col-12">
                <div class="alert alert-info">
                    <h4>ğŸ“– ØªØ¹Ù„ÙŠÙ…Ø§Øª Ø§Ù„Ø§Ø³ØªØ®Ø¯Ø§Ù…:</h4>
                    <ol>
                        <li><strong>Ø¬Ø¯ÙŠØ¯:</strong> Ø£Ø¯Ø®Ù„ Ø±Ø§Ø¨Ø· GitHub Pages Ù„Ø¬Ù„Ø¨ ÙˆØªØ­Ù„ÙŠÙ„ Ø¬Ù…ÙŠØ¹ Ø§Ù„ØµÙØ­Ø§Øª ØªÙ„Ù‚Ø§Ø¦ÙŠØ§Ù‹</li>
                        <li><strong>Ø¬Ø¯ÙŠØ¯:</strong> Ø§Ø±ÙØ¹ Ù…Ù„Ù robots.txt Ù„Ø§Ø³ØªØ®Ø±Ø§Ø¬ Ø§Ù„ØµÙØ­Ø§Øª Ø§Ù„Ù…Ø³ØªØ¨Ø¹Ø¯Ø© ÙˆØ§Ù„Ù…Ø³Ù…ÙˆØ­Ø©</li>
                        <li><strong>Ø¬Ø¯ÙŠØ¯:</strong> Ø§Ø±ÙØ¹ Ù…Ù„Ù manifest.json Ù„Ø§Ø³ØªØ®Ø±Ø§Ø¬ Ø£Ø³Ù…Ø§Ø¡ Ø£Ù‚Ø³Ø§Ù… ØªØ·Ø¨ÙŠÙ‚ PWA</li>
                        <li><strong>Ù…Ø­Ø³Ù†:</strong> Ø§Ø±ÙØ¹ Ù…Ù„Ù sitemap.xml Ù„Ø§Ø³ØªØ®Ø±Ø§Ø¬ Ø¬Ù…ÙŠØ¹ Ø§Ù„Ø±ÙˆØ§Ø¨Ø· ØªÙ„Ù‚Ø§Ø¦ÙŠØ§Ù‹</li>
                        <li><strong>Ù…Ø­Ø³Ù†:</strong> Ø§Ø±ÙØ¹ Ù…Ù„ÙØ§Øª HTML Ù…Ø¨Ø§Ø´Ø±Ø© Ù„Ø§Ø³ØªØ®Ø±Ø§Ø¬ Ø§Ù„Ø¹Ù†Ø§ÙˆÙŠÙ† ÙˆØ§Ù„Ø£ÙˆØµØ§Ù ØªÙ„Ù‚Ø§Ø¦ÙŠÙ‹Ø§</li>
                        <li><strong>Ù…Ø­Ø³Ù†:</strong> Ø§Ø³Ø­Ø¨ ÙˆØ£ÙÙ„Øª Ù…Ù„ÙØ§Øª Ø§Ù„Ù†ØµÙˆØµ ÙÙŠ Ù…Ù†Ø·Ù‚Ø© Ø§Ù„Ø±ÙˆØ§Ø¨Ø·</li>
                        <li>Ø£Ùˆ Ø£Ø¯Ø®Ù„ Ø±ÙˆØ§Ø¨Ø· Ø¬Ù…ÙŠØ¹ ØµÙØ­Ø§Øª Ù…ÙˆÙ‚Ø¹Ùƒ ÙŠØ¯ÙˆÙŠØ§Ù‹</li>
                        <li>Ø§Ø¶ØºØ· "ØªÙˆÙ„ÙŠØ¯ ÙÙ‡Ø±Ø³ Ø§Ù„Ø¨Ø­Ø«"</li>
                        <li><strong>Ø¬Ø¯ÙŠØ¯:</strong> Ø±Ø§Ø¬Ø¹ Ø§Ù„Ø¥Ø­ØµØ§Ø¦ÙŠØ§Øª Ø§Ù„Ø¯Ø§Ø®Ù„ÙŠØ© ÙˆØ§Ù„Ø¹Ø¯Ø§Ø¯ Ø§Ù„Ù…Ø¨Ø§Ø´Ø±</li>
                        <li><strong>Ø¬Ø¯ÙŠØ¯:</strong> Ø§Ø³ØªØ®Ø¯Ù… Ø§Ù„ØªØµÙÙŠØ© Ù„Ù„Ø¨Ø­Ø« ÙÙŠ Ø§Ù„Ù†ØªØ§Ø¦Ø¬</li>
                        <li><strong>Ù…Ø­Ø³Ù†:</strong> Ø¹Ø¯Ù‘Ù„ Ø§Ù„Ù…Ø­ØªÙˆÙ‰ Ù…Ø¨Ø§Ø´Ø±Ø© ÙÙŠ Ø§Ù„Ù†ØªØ§Ø¦Ø¬</li>
                        <li><strong>Ù…Ø­Ø³Ù†:</strong> ØµØ¯Ù‘Ø± ÙƒÙ€ JSONØŒ CSVØŒ Ø£Ùˆ ZIP Ø´Ø§Ù…Ù„</li>
                        <li><strong>Ù…Ø­Ø³Ù†:</strong> Ø§Ù†Ø³Ø® Ø§Ù„Ø¹Ù†Ø§ÙˆÙŠÙ† Ø£Ùˆ Ø§Ù„Ø±ÙˆØ§Ø¨Ø· Ø£Ùˆ Ø§Ù„Ø£ÙˆØµØ§Ù Ù…Ù†ÙØ±Ø¯Ø©</li>
                        <li><strong>ØªÙ„Ù‚Ø§Ø¦ÙŠ:</strong> Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª Ù…Ø­ÙÙˆØ¸Ø© ØªÙ„Ù‚Ø§Ø¦ÙŠØ§Ù‹ ÙÙŠ Ø§Ù„Ù…ØªØµÙØ­</li>
                    </ol>
                </div>
            </div>
        </div>
    </div>

    <!-- Toast Container -->
    <div class="toast-container position-fixed top-0 end-0 p-3" style="z-index: 9999;">
    </div>

    <!-- Bootstrap JS for Toast functionality -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/bootstrap/5.3.0/js/bootstrap.bundle.min.js"></script>

    <script>
        let searchIndex = [];
        let manualPages = [];
        let analyzedFiles = [];
        let sitemapUrls = [];
        let robotsUrls = [];
        let manifestData = {};
        let githubUrls = [];
        let isDarkMode = localStorage.getItem('darkMode') === 'true';
        let filteredResults = [];
        
        // Initialize dark mode
        if (isDarkMode) {
            document.documentElement.setAttribute('data-theme', 'dark');
            updateDarkModeButton();
        }
        
        // Auto-load data on page load
        window.addEventListener('load', function() {
            loadFromLocalStorage();
            setupTextareaDragDrop();
            setupDropZones();
            setupFilters();
        });
        
        // Dark mode functionality
        function toggleDarkMode() {
            isDarkMode = !isDarkMode;
            localStorage.setItem('darkMode', isDarkMode);
            
            if (isDarkMode) {
                document.documentElement.setAttribute('data-theme', 'dark');
            } else {
                document.documentElement.removeAttribute('data-theme');
            }
            
            updateDarkModeButton();
            showNotification(isDarkMode ? 'ØªÙ… ØªÙØ¹ÙŠÙ„ Ø§Ù„ÙˆØ¶Ø¹ Ø§Ù„Ù„ÙŠÙ„ÙŠ ğŸŒ™' : 'ØªÙ… ØªÙØ¹ÙŠÙ„ Ø§Ù„ÙˆØ¶Ø¹ Ø§Ù„Ù†Ù‡Ø§Ø±ÙŠ â˜€ï¸', 'info');
        }
        
        function updateDarkModeButton() {
            const button = document.querySelector('.dark-mode-toggle');
            button.innerHTML = isDarkMode ? 'â˜€ï¸ Ø§Ù„ÙˆØ¶Ø¹ Ø§Ù„Ù†Ù‡Ø§Ø±ÙŠ' : 'ğŸŒ™ Ø§Ù„ÙˆØ¶Ø¹ Ø§Ù„Ù„ÙŠÙ„ÙŠ';
        }

        // Live counter functionality
        function updateLiveCounter() {
            const counter = document.getElementById('liveCounter');
            const counterValue = document.getElementById('counterValue');
            
            if (searchIndex.length > 0) {
                counter.style.display = 'block';
                counterValue.textContent = searchIndex.length;
            } else {
                counter.style.display = 'none';
            }
        }

        // Statistics functionality
        function updateStatistics() {
            const statsPanel = document.getElementById('statsPanel');
            
            if (searchIndex.length === 0) {
                statsPanel.style.display = 'none';
                return;
            }

            statsPanel.style.display = 'block';
            
            // Calculate statistics
            const totalPages = searchIndex.length;
            const allKeywords = searchIndex.flatMap(item => item.tags || []);
            const totalKeywords = allKeywords.length;
            const uniqueCategories = [...new Set(searchIndex.map(item => item.category))].length;
            
            // Find most frequent keyword
            const keywordCount = {};
            allKeywords.forEach(keyword => {
                keywordCount[keyword] = (keywordCount[keyword] || 0) + 1;
            });
            
            const topKeyword = Object.keys(keywordCount).reduce((a, b) => 
                keywordCount[a] > keywordCount[b] ? a : b, '-'
            );
            
            // Update display
            document.getElementById('statPages').textContent = totalPages;
            document.getElementById('statKeywords').textContent = totalKeywords;
            document.getElementById('statCategories').textContent = uniqueCategories;
            document.getElementById('statTopKeyword').textContent = topKeyword + (keywordCount[topKeyword] ? ` (${keywordCount[topKeyword]})` : '');
        }

        // Filter functionality
        function setupFilters() {
            const categoryFilter = document.getElementById('categoryFilter');
            const keywordFilter = document.getElementById('keywordFilter');
            
            categoryFilter.addEventListener('change', applyFilters);
            keywordFilter.addEventListener('input', applyFilters);
        }

        function updateFilterOptions() {
            const categoryFilter = document.getElementById('categoryFilter');
            const categories = [...new Set(searchIndex.map(item => item.category))];
            
            categoryFilter.innerHTML = '<option value="">Ø¬Ù…ÙŠØ¹ Ø§Ù„ÙØ¦Ø§Øª</option>';
            categories.forEach(category => {
                const option = document.createElement('option');
                option.value = category;
                option.textContent = category;
                categoryFilter.appendChild(option);
            });
        }

        function applyFilters() {
            const categoryFilter = document.getElementById('categoryFilter').value;
            const keywordFilter = document.getElementById('keywordFilter').value.toLowerCase();
            
            filteredResults = searchIndex.filter(item => {
                const matchesCategory = !categoryFilter || item.category === categoryFilter;
                const matchesKeyword = !keywordFilter || 
                    item.title.toLowerCase().includes(keywordFilter) ||
                    item.description.toLowerCase().includes(keywordFilter) ||
                    (item.tags && item.tags.some(tag => tag.toLowerCase().includes(keywordFilter)));
                
                return matchesCategory && matchesKeyword;
            });
            
            displayResults(filteredResults);
        }

        // Delete all data functionality
        function deleteAllData() {
            if (confirm('Ù‡Ù„ Ø£Ù†Øª Ù…ØªØ£ÙƒØ¯ Ù…Ù† Ø­Ø°Ù Ø¬Ù…ÙŠØ¹ Ø§Ù„Ø¨ÙŠØ§Ù†Ø§ØªØŸ Ù„Ø§ ÙŠÙ…ÙƒÙ† Ø§Ù„ØªØ±Ø§Ø¬Ø¹ Ø¹Ù† Ù‡Ø°Ø§ Ø§Ù„Ø¥Ø¬Ø±Ø§Ø¡.')) {
                searchIndex = [];
                manualPages = [];
                analyzedFiles = [];
                sitemapUrls = [];
                robotsUrls = [];
                manifestData = {};
                githubUrls = [];
                filteredResults = [];
                
                document.getElementById('urlInput').value = '';
                document.getElementById('results').innerHTML = '<p class="text-muted text-center">ØªÙ… Ø­Ø°Ù Ø¬Ù…ÙŠØ¹ Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª</p>';
                document.getElementById('exportButtons').style.display = 'none';
                document.getElementById('statsPanel').style.display = 'none';
                document.getElementById('filterSection').style.display = 'none';
                
                updateLiveCounter();
                localStorage.removeItem('searchIndexGenerator');
                
                showNotification('ØªÙ… Ø­Ø°Ù Ø¬Ù…ÙŠØ¹ Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª Ø¨Ù†Ø¬Ø§Ø­! ğŸ—‘ï¸', 'success');
            }
        }

        // GitHub Pages fetch functionality
        async function fetchFromGitHub() {
            const githubUrl = document.getElementById('githubUrl').value.trim();
            
            if (!githubUrl) {
                showNotification('ÙŠØ±Ø¬Ù‰ Ø¥Ø¯Ø®Ø§Ù„ Ø±Ø§Ø¨Ø· GitHub Pages ØµØ§Ù„Ø­', 'warning');
                return;
            }
            
            try {
                showNotification('Ø¬Ø§Ø±ÙŠ Ø¬Ù„Ø¨ Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª Ù…Ù† GitHub Pages...', 'info');
                
                // This is a simplified implementation
                // In a real scenario, you'd need to handle CORS and use GitHub API
                const response = await fetch(githubUrl);
                const html = await response.text();
                
                // Extract links from the main page
                const parser = new DOMParser();
                const doc = parser.parseFromString(html, 'text/html');
                const links = Array.from(doc.querySelectorAll('a[href]'))
                    .map(a => a.getAttribute('href'))
                    .filter(href => href && href.endsWith('.html') && !href.startsWith('http'))
                    .map(href => href.startsWith('/') ? href : '/' + href);
                
                if (links.length > 0) {
                    githubUrls = links;
                    const currentUrls = document.getElementById('urlInput').value;
                    const newUrls = currentUrls ? currentUrls + '\n' + links.join('\n') : links.join('\n');
                    document.getElementById('urlInput').value = newUrls;
                    
                    showNotification(`ØªÙ… Ø¬Ù„Ø¨ ${links.length} Ø±Ø§Ø¨Ø· Ù…Ù† GitHub Pages! ğŸ™`, 'success');
                    autoSave();
                } else {
                    showNotification('Ù„Ù… ÙŠØªÙ… Ø§Ù„Ø¹Ø«ÙˆØ± Ø¹Ù„Ù‰ Ø±ÙˆØ§Ø¨Ø· HTML ÙÙŠ Ø§Ù„ØµÙØ­Ø©', 'warning');
                }
                
            } catch (error) {
                showNotification('Ø®Ø·Ø£ ÙÙŠ Ø¬Ù„Ø¨ Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª Ù…Ù† GitHub: ' + error.message, 'danger');
            }
        }

        // Setup all drop zones
        function setupDropZones() {
            setupRobotsDropZone();
            setupManifestDropZone();
            setupSitemapDropZone();
        }

        // Robots.txt functionality
        function setupRobotsDropZone() {
            const robotsDropZone = document.getElementById('robotsDropZone');
            const robotsFileInput = document.getElementById('robotsFileInput');
            
            robotsDropZone.addEventListener('click', () => robotsFileInput.click());
            
            robotsDropZone.addEventListener('dragover', (e) => {
                e.preventDefault();
                robotsDropZone.classList.add('dragover');
            });
            
            robotsDropZone.addEventListener('dragleave', () => {
                robotsDropZone.classList.remove('dragover');
            });
            
            robotsDropZone.addEventListener('drop', (e) => {
                e.preventDefault();
                robotsDropZone.classList.remove('dragover');
                const files = Array.from(e.dataTransfer.files).filter(file => 
                    file.type === 'text/plain' || file.name.endsWith('.txt')
                );
                if (files.length > 0) {
                    processRobotsFile(files[0]);
                }
            });
            
            robotsFileInput.addEventListener('change', (e) => {
                if (e.target.files.length > 0) {
                    processRobotsFile(e.target.files[0]);
                }
            });
        }

        async function processRobotsFile(file) {
            try {
                const content = await readFileContent(file);
                const lines = content.split('\n').map(line => line.trim());
                
                const newRobotsUrls = [];
                let currentUserAgent = '*';
                
                lines.forEach(line => {
                    if (line.toLowerCase().startsWith('user-agent:')) {
                        currentUserAgent = line.split(':')[1].trim();
                    } else if (line.toLowerCase().startsWith('disallow:')) {
                        const path = line.split(':')[1].trim();
                        if (path && path !== '/' && !robotsUrls.includes(path) && !newRobotsUrls.includes(path)) {
                            newRobotsUrls.push(path);
                        }
                    } else if (line.toLowerCase().startsWith('allow:')) {
                        const path = line.split(':')[1].trim();
                        if (path && path !== '/' && !robotsUrls.includes(path) && !newRobotsUrls.includes(path)) {
                            newRobotsUrls.push(path);
                        }
                    }
                });
                
                if (newRobotsUrls.length > 0) {
                    // Append to existing robotsUrls
                    robotsUrls.push(...newRobotsUrls);
                    
                    const currentUrls = document.getElementById('urlInput').value;
                    const newUrls = currentUrls ? currentUrls + '\n' + newRobotsUrls.join('\n') : newRobotsUrls.join('\n');
                    document.getElementById('urlInput').value = newUrls;
                    
                    showNotification(`ØªÙ… Ø§Ø³ØªØ®Ø±Ø§Ø¬ ${newRobotsUrls.length} Ù…Ø³Ø§Ø± Ø¬Ø¯ÙŠØ¯ Ù…Ù† robots.txt! ğŸ¤–`, 'success');
                    autoSave();
                } else {
                    showNotification('Ù„Ù… ÙŠØªÙ… Ø§Ù„Ø¹Ø«ÙˆØ± Ø¹Ù„Ù‰ Ù…Ø³Ø§Ø±Ø§Øª Ø¬Ø¯ÙŠØ¯Ø© ÙÙŠ Ù…Ù„Ù robots.txt', 'warning');
                }
                
            } catch (error) {
                showNotification('Ø®Ø·Ø£ ÙÙŠ Ù…Ø¹Ø§Ù„Ø¬Ø© Ù…Ù„Ù robots.txt: ' + error.message, 'danger');
            }
        }

        // Manifest.json functionality
        function setupManifestDropZone() {
            const manifestDropZone = document.getElementById('manifestDropZone');
            const manifestFileInput = document.getElementById('manifestFileInput');
            
            manifestDropZone.addEventListener('click', () => manifestFileInput.click());
            
            manifestDropZone.addEventListener('dragover', (e) => {
                e.preventDefault();
                manifestDropZone.classList.add('dragover');
            });
            
            manifestDropZone.addEventListener('dragleave', () => {
                manifestDropZone.classList.remove('dragover');
            });
            
            manifestDropZone.addEventListener('drop', (e) => {
                e.preventDefault();
                manifestDropZone.classList.remove('dragover');
                const files = Array.from(e.dataTransfer.files).filter(file => 
                    file.type === 'application/json' || file.name.endsWith('.json')
                );
                if (files.length > 0) {
                    processManifestFile(files[0]);
                }
            });
            
            manifestFileInput.addEventListener('change', (e) => {
                if (e.target.files.length > 0) {
                    processManifestFile(e.target.files[0]);
                }
            });
        }

        async function processManifestFile(file) {
            try {
                const content = await readFileContent(file);
                manifestData = JSON.parse(content);
                
                const extractedUrls = [];
                
                // Extract from icons
                if (manifestData.icons) {
                    manifestData.icons.forEach(icon => {
                        if (icon.src) {
                            extractedUrls.push(icon.src);
                        }
                    });
                }
                
                // Extract from screenshots
                if (manifestData.screenshots) {
                    manifestData.screenshots.forEach(screenshot => {
                        if (screenshot.src) {
                            extractedUrls.push(screenshot.src);
                        }
                    });
                }
                
                // Extract start_url
                if (manifestData.start_url) {
                    extractedUrls.push(manifestData.start_url);
                }
                
                // Extract from shortcuts
                if (manifestData.shortcuts) {
                    manifestData.shortcuts.forEach(shortcut => {
                        if (shortcut.url) {
                            extractedUrls.push(shortcut.url);
                        }
                    });
                }
                
                if (extractedUrls.length > 0) {
                    const currentUrls = document.getElementById('urlInput').value;
                    const newUrls = currentUrls ? currentUrls + '\n' + extractedUrls.join('\n') : extractedUrls.join('\n');
                    document.getElementById('urlInput').value = newUrls;
                    
                    showNotification(`ØªÙ… Ø§Ø³ØªØ®Ø±Ø§Ø¬ ${extractedUrls.length} Ù…Ø³Ø§Ø± Ù…Ù† manifest.json! ğŸ“±`, 'success');
                    autoSave();
                } else {
                    showNotification('Ù„Ù… ÙŠØªÙ… Ø§Ù„Ø¹Ø«ÙˆØ± Ø¹Ù„Ù‰ Ù…Ø³Ø§Ø±Ø§Øª ØµØ§Ù„Ø­Ø© ÙÙŠ Ù…Ù„Ù manifest.json', 'warning');
                }
                
            } catch (error) {
                showNotification('Ø®Ø·Ø£ ÙÙŠ Ù…Ø¹Ø§Ù„Ø¬Ø© Ù…Ù„Ù manifest.json: ' + error.message, 'danger');
            }
        }
        
        // Setup drag and drop for textarea
        function setupTextareaDragDrop() {
            const textarea = document.getElementById('urlInput');
            
            textarea.addEventListener('dragover', (e) => {
                e.preventDefault();
                textarea.classList.add('dragover');
            });
            
            textarea.addEventListener('dragleave', () => {
                textarea.classList.remove('dragover');
            });
            
            textarea.addEventListener('drop', (e) => {
                e.preventDefault();
                textarea.classList.remove('dragover');
                
                const files = Array.from(e.dataTransfer.files).filter(file => 
                    file.type === 'text/plain' || file.name.endsWith('.txt') || file.name.endsWith('.json')
                );
                
                if (files.length > 0) {
                    processDroppedTextFiles(files);
                }
            });
        }
        
        async function processDroppedTextFiles(files) {
            for (const file of files) {
                try {
                    const content = await readFileContent(file);
                    let urls = [];
                    
                    if (file.name.endsWith('.json')) {
                        const jsonData = JSON.parse(content);
                        if (Array.isArray(jsonData)) {
                            urls = jsonData;
                        } else if (jsonData.urls && Array.isArray(jsonData.urls)) {
                            urls = jsonData.urls;
                        }
                    } else {
                        urls = content.split('\n')
                            .map(line => line.trim())
                            .filter(line => line && !line.startsWith('#'));
                    }
                    
                    if (urls.length > 0) {
                        const currentUrls = document.getElementById('urlInput').value;
                        const newUrls = currentUrls ? currentUrls + '\n' + urls.join('\n') : urls.join('\n');
                        document.getElementById('urlInput').value = newUrls;
                        showNotification(`ØªÙ… Ø¥Ø¶Ø§ÙØ© ${urls.length} Ø±Ø§Ø¨Ø· Ù…Ù† ${file.name}! ğŸ“¥`, 'success');
                        autoSave();
                    }
                } catch (error) {
                    showNotification(`Ø®Ø·Ø£ ÙÙŠ Ù…Ø¹Ø§Ù„Ø¬Ø© ${file.name}: ${error.message}`, 'danger');
                }
            }
        }
        
        // Auto-save data when changes occur
        function autoSave() {
            saveToLocalStorage();
        }
        
        // LocalStorage functions
        function saveToLocalStorage() {
            const data = {
                searchIndex: searchIndex,
                manualPages: manualPages,
                analyzedFiles: analyzedFiles,
                sitemapUrls: sitemapUrls,
                robotsUrls: robotsUrls,
                manifestData: manifestData,
                githubUrls: githubUrls,
                urlInput: document.getElementById('urlInput').value,
                timestamp: new Date().toISOString()
            };
            
            try {
                localStorage.setItem('searchIndexGenerator', JSON.stringify(data));
                showNotification('ØªÙ… Ø­ÙØ¸ Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª Ø¨Ù†Ø¬Ø§Ø­! âœ…', 'success');
            } catch (error) {
                showNotification('Ø®Ø·Ø£ ÙÙŠ Ø­ÙØ¸ Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª: ' + error.message, 'danger');
            }
        }
        
        function loadFromLocalStorage() {
            try {
                const savedData = localStorage.getItem('searchIndexGenerator');
                if (savedData) {
                    const data = JSON.parse(savedData);
                    searchIndex = data.searchIndex || [];
                    manualPages = data.manualPages || [];
                    analyzedFiles = data.analyzedFiles || [];
                    sitemapUrls = data.sitemapUrls || [];
                    robotsUrls = data.robotsUrls || [];
                    manifestData = data.manifestData || {};
                    githubUrls = data.githubUrls || [];
                    
                    if (data.urlInput) {
                        document.getElementById('urlInput').value = data.urlInput;
                    }
                    
                    if (searchIndex.length > 0) {
                        displayResults();
                        updateStatistics();
                        updateLiveCounter();
                        updateFilterOptions();
                        document.getElementById('filterSection').style.display = 'block';
                    }
                    
                    showNotification('ØªÙ… ØªØ­Ù…ÙŠÙ„ Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ù…Ø­ÙÙˆØ¸Ø©! ğŸ“‚', 'info');
                }
            } catch (error) {
                showNotification('Ø®Ø·Ø£ ÙÙŠ ØªØ­Ù…ÙŠÙ„ Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª: ' + error.message, 'warning');
            }
        }
        
        // Enhanced notification system using Bootstrap 5.3 Toasts
        function showNotification(message, type = 'info') {
            const toastContainer = document.querySelector('.toast-container');
            const toastId = 'toast-' + Date.now();
            
            // Map notification types to Bootstrap toast styles
            const typeMapping = {
                'info': { bg: 'bg-info', icon: 'â„¹ï¸', title: 'Ù…Ø¹Ù„ÙˆÙ…Ø§Øª' },
                'success': { bg: 'bg-success', icon: 'âœ…', title: 'Ù†Ø¬Ø­' },
                'warning': { bg: 'bg-warning', icon: 'âš ï¸', title: 'ØªØ­Ø°ÙŠØ±' },
                'danger': { bg: 'bg-danger', icon: 'âŒ', title: 'Ø®Ø·Ø£' },
                'error': { bg: 'bg-danger', icon: 'âŒ', title: 'Ø®Ø·Ø£' }
            };
            
            const toastConfig = typeMapping[type] || typeMapping['info'];
            
            // Create toast element
            const toastElement = document.createElement('div');
            toastElement.id = toastId;
            toastElement.className = `toast fade show ${toastConfig.bg} text-white`;
            toastElement.setAttribute('role', 'alert');
            toastElement.setAttribute('aria-live', 'assertive');
            toastElement.setAttribute('aria-atomic', 'true');
            
            toastElement.innerHTML = `
                <div class="toast-header ${toastConfig.bg} text-white border-0">
                    <span class="me-2">${toastConfig.icon}</span>
                    <strong class="me-auto">${toastConfig.title}</strong>
                    <small class="opacity-75">Ø§Ù„Ø¢Ù†</small>
                    <button type="button" class="btn-close btn-close-white ms-2" data-bs-dismiss="toast" aria-label="Ø¥ØºÙ„Ø§Ù‚"></button>
                </div>
                <div class="toast-body">
                    ${message}
                </div>
            `;
            
            // Add to container
            toastContainer.appendChild(toastElement);
            
            // Initialize Bootstrap toast
            const bsToast = new bootstrap.Toast(toastElement, {
                autohide: true,
                delay: 5000
            });
            
            // Show the toast
            bsToast.show();
            
            // Remove from DOM after it's hidden
            toastElement.addEventListener('hidden.bs.toast', () => {
                if (toastElement.parentNode) {
                    toastElement.parentNode.removeChild(toastElement);
                }
            });
        }
        
        // Sitemap.xml functionality
        function setupSitemapDropZone() {
            const sitemapDropZone = document.getElementById('sitemapDropZone');
            const sitemapFileInput = document.getElementById('sitemapFileInput');
            
            sitemapDropZone.addEventListener('click', () => sitemapFileInput.click());
            
            sitemapDropZone.addEventListener('dragover', (e) => {
                e.preventDefault();
                sitemapDropZone.classList.add('dragover');
            });
            
            sitemapDropZone.addEventListener('dragleave', () => {
                sitemapDropZone.classList.remove('dragover');
            });
            
            sitemapDropZone.addEventListener('drop', (e) => {
                e.preventDefault();
                sitemapDropZone.classList.remove('dragover');
                const files = Array.from(e.dataTransfer.files).filter(file => 
                    file.type === 'text/xml' || file.name.endsWith('.xml')
                );
                if (files.length > 0) {
                    processSitemapFile(files[0]);
                }
            });
            
            sitemapFileInput.addEventListener('change', (e) => {
                if (e.target.files.length > 0) {
                    processSitemapFile(e.target.files[0]);
                }
            });
        }
        
        async function processSitemapFile(file) {
            try {
                const content = await readFileContent(file);
                const parser = new DOMParser();
                const xmlDoc = parser.parseFromString(content, 'text/xml');
                
                // Check for parsing errors
                const parseError = xmlDoc.querySelector('parsererror');
                if (parseError) {
                    throw new Error('Ø®Ø·Ø£ ÙÙŠ ØªØ­Ù„ÙŠÙ„ Ù…Ù„Ù XML');
                }
                
                // Extract URLs from sitemap
                const urlElements = xmlDoc.querySelectorAll('url > loc, sitemap > loc');
                const newSitemapUrls = [];
                
                urlElements.forEach(element => {
                    let url = element.textContent.trim();
                    // Convert full URLs to relative paths
                    try {
                        const urlObj = new URL(url);
                        url = urlObj.pathname;
                        if (url === '/') url = '/index.html';
                        if (!url.includes('.')) url += '.html';
                    } catch (e) {
                        // If not a valid URL, treat as relative path
                    }
                    
                    if (url && !sitemapUrls.includes(url) && !newSitemapUrls.includes(url)) {
                        newSitemapUrls.push(url);
                    }
                });
                
                if (newSitemapUrls.length > 0) {
                    // Append to existing sitemapUrls
                    sitemapUrls.push(...newSitemapUrls);
                    
                    // Add to URL input
                    const currentUrls = document.getElementById('urlInput').value;
                    const newUrls = currentUrls ? currentUrls + '\n' + newSitemapUrls.join('\n') : newSitemapUrls.join('\n');
                    document.getElementById('urlInput').value = newUrls;
                    
                    showNotification(`ØªÙ… Ø§Ø³ØªØ®Ø±Ø§Ø¬ ${newSitemapUrls.length} Ø±Ø§Ø¨Ø· Ø¬Ø¯ÙŠØ¯ Ù…Ù† Sitemap! ğŸ—ºï¸`, 'success');
                    autoSave();
                } else {
                    showNotification('Ù„Ù… ÙŠØªÙ… Ø§Ù„Ø¹Ø«ÙˆØ± Ø¹Ù„Ù‰ Ø±ÙˆØ§Ø¨Ø· Ø¬Ø¯ÙŠØ¯Ø© ÙÙŠ Ù…Ù„Ù Sitemap', 'warning');
                }
                
            } catch (error) {
                showNotification('Ø®Ø·Ø£ ÙÙŠ Ù…Ø¹Ø§Ù„Ø¬Ø© Ù…Ù„Ù Sitemap: ' + error.message, 'danger');
            }
        }
        
        // File drop zone functionality
        const fileDropZone = document.getElementById('fileDropZone');
        const htmlFileInput = document.getElementById('htmlFileInput');
        
        fileDropZone.addEventListener('click', () => htmlFileInput.click());
        
        fileDropZone.addEventListener('dragover', (e) => {
            e.preventDefault();
            fileDropZone.classList.add('dragover');
        });
        
        fileDropZone.addEventListener('dragleave', () => {
            fileDropZone.classList.remove('dragover');
        });
        
        fileDropZone.addEventListener('drop', (e) => {
            e.preventDefault();
            fileDropZone.classList.remove('dragover');
            const files = Array.from(e.dataTransfer.files).filter(file => 
                file.type === 'text/html' || file.name.endsWith('.html') || file.name.endsWith('.htm')
            );
            if (files.length > 0) {
                processHtmlFiles(files);
            }
        });
        
        htmlFileInput.addEventListener('change', (e) => {
            if (e.target.files.length > 0) {
                processHtmlFiles(Array.from(e.target.files));
            }
        });
        
        // Process HTML files with enhanced content extraction
        async function processHtmlFiles(files) {
            const progressContainer = document.getElementById('progressContainer');
            const progressBar = document.getElementById('progressBar');
            const progressText = document.getElementById('progressText');
            
            progressContainer.style.display = 'block';
            // Don't reset analyzedFiles - append to existing data instead
            // analyzedFiles = []; // REMOVED: This was causing data loss
            
            const newAnalyzedFiles = [];
            
            for (let i = 0; i < files.length; i++) {
                const file = files[i];
                const progress = ((i + 1) / files.length) * 100;
                
                progressBar.style.width = progress + '%';
                progressText.textContent = `Ù…Ø¹Ø§Ù„Ø¬Ø© ${file.name} (${i + 1}/${files.length})`;
                
                try {
                    // Check if this file was already analyzed
                    const existingAnalysis = analyzedFiles.find(existing => existing.filename === file.name);
                    
                    if (!existingAnalysis) {
                        const content = await readFileContent(file);
                        const analysis = analyzeHtmlContent(content, file.name);
                        analyzedFiles.push(analysis);
                        newAnalyzedFiles.push(analysis);
                    }
                } catch (error) {
                    console.error('Error processing file:', file.name, error);
                }
                
                // Small delay for UI responsiveness
                await new Promise(resolve => setTimeout(resolve, 100));
            }
            
            progressContainer.style.display = 'none';
            
            if (newAnalyzedFiles.length > 0) {
                showNotification(`ØªÙ… ØªØ­Ù„ÙŠÙ„ ${newAnalyzedFiles.length} Ù…Ù„Ù HTML Ø¬Ø¯ÙŠØ¯ Ø¨Ù†Ø¬Ø§Ø­! Ø¥Ø¬Ù…Ø§Ù„ÙŠ Ø§Ù„Ù…Ù„ÙØ§Øª: ${analyzedFiles.length} ğŸ‰`, 'success');
            } else {
                showNotification('Ø¬Ù…ÙŠØ¹ Ø§Ù„Ù…Ù„ÙØ§Øª ØªÙ… ØªØ­Ù„ÙŠÙ„Ù‡Ø§ Ù…Ø³Ø¨Ù‚Ø§Ù‹ - Ù„Ø§ ØªÙˆØ¬Ø¯ Ù…Ù„ÙØ§Øª Ø¬Ø¯ÙŠØ¯Ø©', 'info');
            }
            
            autoSave();
        }
        
        function readFileContent(file) {
            return new Promise((resolve, reject) => {
                const reader = new FileReader();
                reader.onload = e => resolve(e.target.result);
                reader.onerror = reject;
                reader.readAsText(file, 'UTF-8');
            });
        }
        
        function analyzeHtmlContent(content, filename) {
            const parser = new DOMParser();
            const doc = parser.parseFromString(content, 'text/html');
            
            // Extract title
            const titleElement = doc.querySelector('title');
            let title = titleElement ? titleElement.textContent.trim() : '';
            
            // Extract description from meta tags
            let description = '';
            const metaDesc = doc.querySelector('meta[name="description"]') || 
                           doc.querySelector('meta[property="og:description"]');
            if (metaDesc) {
                description = metaDesc.getAttribute('content') || '';
            }
            
            // Enhanced content extraction from article/main sections
            if (!description) {
                const articleElement = doc.querySelector('article');
                const mainElement = doc.querySelector('main');
                const contentElement = articleElement || mainElement;
                
                if (contentElement) {
                    const firstParagraph = contentElement.querySelector('p');
                    if (firstParagraph) {
                        description = firstParagraph.textContent.trim().substring(0, 200) + '...';
                    }
                }
            }
            
            // Extract keywords
            let keywords = [];
            const metaKeywords = doc.querySelector('meta[name="keywords"]');
            if (metaKeywords) {
                keywords = metaKeywords.getAttribute('content')
                    .split(',')
                    .map(k => k.trim())
                    .filter(k => k);
            }
            
            // Extract headings for additional context
            const headings = Array.from(doc.querySelectorAll('h1, h2, h3'))
                .map(h => h.textContent.trim())
                .filter(h => h);
            
            // Fallback title from filename
            if (!title) {
                title = filename.replace(/\.(html?|htm)$/i, '')
                    .replace(/[-_]/g, ' ')
                    .replace(/\b\w/g, l => l.toUpperCase());
            }
            
            // Fallback description
            if (!description && headings.length > 0) {
                description = `ØµÙØ­Ø© ${title} - ${headings[0]}`;
            } else if (!description) {
                description = `ØµÙØ­Ø© ${title}`;
            }
            
            return {
                filename: filename,
                title: title,
                description: description,
                keywords: keywords,
                headings: headings,
                url: '/' + filename,
                content: content // Store content for ZIP export
            };
        }
        
        // Enhanced tag extraction from URLs
        function extractTagsFromUrl(url) {
            const tags = [];
            const pathParts = url.split('/').filter(part => part && part !== '');
            
            pathParts.forEach(part => {
                // Remove file extensions
                const cleanPart = part.replace(/\.(html?|htm|php|asp|jsp)$/i, '');
                
                // Split by common separators
                const subParts = cleanPart.split(/[-_\s]+/);
                
                subParts.forEach(subPart => {
                    if (subPart.length > 2) {
                        tags.push(subPart.toLowerCase());
                    }
                });
            });
            
            // Add common Arabic translations
            const translations = {
                'index': 'Ø§Ù„Ø±Ø¦ÙŠØ³ÙŠØ©',
                'home': 'Ø§Ù„Ø±Ø¦ÙŠØ³ÙŠØ©',
                'about': 'Ù…Ù† Ù†Ø­Ù†',
                'contact': 'Ø§ØªØµÙ„ Ø¨Ù†Ø§',
                'services': 'Ø®Ø¯Ù…Ø§Øª',
                'products': 'Ù…Ù†ØªØ¬Ø§Øª',
                'blog': 'Ù…Ø¯ÙˆÙ†Ø©',
                'news': 'Ø£Ø®Ø¨Ø§Ø±',
                'portfolio': 'Ø£Ø¹Ù…Ø§Ù„',
                'team': 'ÙØ±ÙŠÙ‚',
                'pricing': 'Ø£Ø³Ø¹Ø§Ø±',
                'faq': 'Ø£Ø³Ø¦Ù„Ø© Ø´Ø§Ø¦Ø¹Ø©'
            };
            
            tags.forEach(tag => {
                if (translations[tag]) {
                    tags.push(translations[tag]);
                }
            });
            
            return [...new Set(tags)]; // Remove duplicates
        }
        
        // Bulk import functionality
        function importUrlsFile() {
            const fileInput = document.getElementById('urlsFileInput');
            const file = fileInput.files[0];
            
            if (!file) {
                alert('ÙŠØ±Ø¬Ù‰ Ø§Ø®ØªÙŠØ§Ø± Ù…Ù„Ù Ø£ÙˆÙ„Ø§Ù‹');
                return;
            }
            
            const reader = new FileReader();
            reader.onload = function(e) {
                const content = e.target.result;
                let urls = [];
                
                try {
                    if (file.name.endsWith('.json')) {
                        const jsonData = JSON.parse(content);
                        if (Array.isArray(jsonData)) {
                            urls = jsonData;
                        } else if (jsonData.urls && Array.isArray(jsonData.urls)) {
                            urls = jsonData.urls;
                        }
                    } else {
                        // Text file
                        urls = content.split('\n')
                            .map(line => line.trim())
                            .filter(line => line && !line.startsWith('#'));
                    }
                    
                    if (urls.length > 0) {
                        const currentUrls = document.getElementById('urlInput').value;
                        const newUrls = currentUrls ? currentUrls + '\n' + urls.join('\n') : urls.join('\n');
                        document.getElementById('urlInput').value = newUrls;
                        showNotification(`ØªÙ… Ø§Ø³ØªÙŠØ±Ø§Ø¯ ${urls.length} Ø±Ø§Ø¨Ø· Ø¨Ù†Ø¬Ø§Ø­! ğŸ“¥`, 'success');
                        autoSave();
                    } else {
                        alert('Ù„Ù… ÙŠØªÙ… Ø§Ù„Ø¹Ø«ÙˆØ± Ø¹Ù„Ù‰ Ø±ÙˆØ§Ø¨Ø· ØµØ§Ù„Ø­Ø© ÙÙŠ Ø§Ù„Ù…Ù„Ù');
                    }
                } catch (error) {
                    alert('Ø®Ø·Ø£ ÙÙŠ Ù‚Ø±Ø§Ø¡Ø© Ø§Ù„Ù…Ù„Ù: ' + error.message);
                }
            };
            
            reader.readAsText(file, 'UTF-8');
        }
        
        // Toggle manual input
        document.getElementById('manualInput').addEventListener('change', function() {
            const section = document.getElementById('manualInputSection');
            section.style.display = this.checked ? 'block' : 'none';
        });
        
        function addManualPage() {
            const title = document.getElementById('pageTitle').value;
            const url = document.getElementById('pageUrl').value;
            const description = document.getElementById('pageDescription').value;
            const category = document.getElementById('pageCategory').value;
            const tags = document.getElementById('pageTags').value.split(',').map(t => t.trim()).filter(t => t);
            
            if (!title || !url) {
                alert('ÙŠØ±Ø¬Ù‰ Ø¥Ø¯Ø®Ø§Ù„ Ø§Ù„Ø¹Ù†ÙˆØ§Ù† ÙˆØ§Ù„Ø±Ø§Ø¨Ø· Ø¹Ù„Ù‰ Ø§Ù„Ø£Ù‚Ù„');
                return;
            }
            
            manualPages.push({
                title,
                url: url.startsWith('/') ? url : '/' + url,
                description,
                category: category || 'Ø¹Ø§Ù…',
                tags
            });
            
            // Clear inputs
            document.getElementById('pageTitle').value = '';
            document.getElementById('pageUrl').value = '';
            document.getElementById('pageDescription').value = '';
            document.getElementById('pageCategory').value = '';
            document.getElementById('pageTags').value = '';
            
            showNotification(`ØªÙ… Ø¥Ø¶Ø§ÙØ©: ${title}`, 'success');
            autoSave();
        }
        
        function generateSearchIndex() {
            const urlInput = document.getElementById('urlInput').value.trim();
            const isManual = document.getElementById('manualInput').checked;
            
            // Don't reset searchIndex - append to existing data instead
            // searchIndex = []; // REMOVED: This was causing data loss
            
            // Find the highest existing ID to continue numbering
            let idCounter = searchIndex.length > 0 ? Math.max(...searchIndex.map(item => item.id)) + 1 : 1;
            
            // Track new items added in this session
            let newItemsCount = 0;
            
            // Add analyzed HTML files first
            if (analyzedFiles.length > 0) {
                analyzedFiles.forEach(file => {
                    // Check if this file is already in searchIndex
                    const existingItem = searchIndex.find(item => 
                        item.url === file.url || 
                        (item.source === 'html_analysis' && item.title === file.title)
                    );
                    
                    if (!existingItem) {
                        searchIndex.push({
                            id: idCounter++,
                            title: file.title,
                            description: file.description,
                            url: file.url,
                            category: 'ØªØ­Ù„ÙŠÙ„ ØªÙ„Ù‚Ø§Ø¦ÙŠ',
                            tags: file.keywords.length > 0 ? file.keywords : extractTagsFromUrl(file.url),
                            source: 'html_analysis',
                            content: file.content
                        });
                        newItemsCount++;
                    }
                });
            }
            
            if (isManual && manualPages.length > 0) {
                // Add manual pages
                manualPages.forEach(page => {
                    // Check if this manual page is already in searchIndex
                    const existingItem = searchIndex.find(item => 
                        item.url === page.url || 
                        (item.source === 'manual' && item.title === page.title)
                    );
                    
                    if (!existingItem) {
                        searchIndex.push({
                            id: idCounter++,
                            title: page.title,
                            description: page.description,
                            url: page.url,
                            category: page.category,
                            tags: page.tags,
                            source: 'manual'
                        });
                        newItemsCount++;
                    }
                });
            } else if (urlInput) {
                // Generate from URLs
                const urls = urlInput.split('\n').filter(url => url.trim());
                
                urls.forEach(url => {
                    url = url.trim();
                    if (!url) return;
                    
                    // Check if this URL already exists in searchIndex
                    const normalizedUrl = url.startsWith('/') ? url : '/' + url;
                    const existingItem = searchIndex.find(item => item.url === normalizedUrl);
                    
                    if (existingItem) {
                        // Skip if already exists
                        return;
                    }
                    
                    // Check if this URL was already analyzed from HTML file
                    const existingAnalysis = analyzedFiles.find(file => 
                        file.url === normalizedUrl || file.filename === url
                    );
                    
                    if (existingAnalysis) {
                        // Skip if already added from HTML analysis
                        return;
                    }
                    
                    // Extract info from URL
                    const fileName = url.split('/').pop().replace('.html', '');
                    const pathParts = url.split('/');
                    const category = pathParts.length > 1 ? pathParts[0] : 'Ø¹Ø§Ù…';
                    
                    // Generate title from filename
                    let title = fileName.replace(/[-_]/g, ' ');
                    title = title.charAt(0).toUpperCase() + title.slice(1);
                    
                    // Special cases
                    if (fileName.toLowerCase() === 'index') title = 'Ø§Ù„ØµÙØ­Ø© Ø§Ù„Ø±Ø¦ÙŠØ³ÙŠØ©';
                    if (fileName.toLowerCase() === 'about') title = 'Ù…Ù† Ù†Ø­Ù†';
                    if (fileName.toLowerCase() === 'contact') title = 'Ø§ØªØµÙ„ Ø¨Ù†Ø§';
                    if (fileName.toLowerCase() === 'services') title = 'Ø®Ø¯Ù…Ø§ØªÙ†Ø§';
                    if (fileName.toLowerCase() === 'blog') title = 'Ø§Ù„Ù…Ø¯ÙˆÙ†Ø©';
                    
                    // Enhanced tag extraction
                    const enhancedTags = extractTagsFromUrl(url);
                    
                    // Determine source
                    let source = 'url_generation';
                    if (sitemapUrls.includes(url)) source = 'sitemap';
                    if (robotsUrls.includes(url)) source = 'robots';
                    if (githubUrls.includes(url)) source = 'github';
                    
                    searchIndex.push({
                        id: idCounter++,
                        title: title,
                        description: `ØµÙØ­Ø© ${title} - ØªØ­ØªÙˆÙŠ Ø¹Ù„Ù‰ Ù…Ø¹Ù„ÙˆÙ…Ø§Øª Ù‡Ø§Ù…Ø© Ø­ÙˆÙ„ ${title.toLowerCase()}`,
                        url: url.startsWith('/') ? url : '/' + url,
                        category: category.charAt(0).toUpperCase() + category.slice(1),
                        tags: enhancedTags.length > 0 ? enhancedTags : [fileName, category],
                        source: source
                    });
                    newItemsCount++;
                });
            }
            
            if (searchIndex.length === 0) {
                alert('ÙŠØ±Ø¬Ù‰ Ø¥Ø¯Ø®Ø§Ù„ Ø±ÙˆØ§Ø¨Ø· Ø§Ù„ØµÙØ­Ø§Øª Ø£Ùˆ Ø±ÙØ¹ Ù…Ù„ÙØ§Øª HTML/Sitemap Ø£Ùˆ Ø§Ø³ØªØ®Ø¯Ø§Ù… Ø§Ù„Ø¥Ø¯Ø®Ø§Ù„ Ø§Ù„ÙŠØ¯ÙˆÙŠ');
                return;
            }
            
            // Show notification about new items added
            if (newItemsCount > 0) {
                showNotification(`ØªÙ… Ø¥Ø¶Ø§ÙØ© ${newItemsCount} Ø¹Ù†ØµØ± Ø¬Ø¯ÙŠØ¯! Ø¥Ø¬Ù…Ø§Ù„ÙŠ Ø§Ù„Ø¹Ù†Ø§ØµØ±: ${searchIndex.length}`, 'success');
            } else {
                showNotification('Ù„Ø§ ØªÙˆØ¬Ø¯ Ø¹Ù†Ø§ØµØ± Ø¬Ø¯ÙŠØ¯Ø© Ù„Ù„Ø¥Ø¶Ø§ÙØ© - Ø¬Ù…ÙŠØ¹ Ø§Ù„Ø¹Ù†Ø§ØµØ± Ù…ÙˆØ¬ÙˆØ¯Ø© Ù…Ø³Ø¨Ù‚Ø§Ù‹', 'info');
            }
            
            displayResults();
            updateStatistics();
            updateLiveCounter();
            updateFilterOptions();
            document.getElementById('filterSection').style.display = 'block';
            autoSave();
        }
        
        function displayResults(resultsToShow = null) {
            const resultsDiv = document.getElementById('results');
            const results = resultsToShow || searchIndex;
            
            if (results.length === 0) {
                resultsDiv.innerHTML = '<p class="text-danger">Ù„Ø§ ØªÙˆØ¬Ø¯ ØµÙØ­Ø§Øª Ù„Ù„Ù…Ø¹Ø§Ù„Ø¬Ø©</p>';
                return;
            }
            
            let html = `<h5>ØªÙ… ØªÙˆÙ„ÙŠØ¯ ${results.length} Ø¹Ù†ØµØ±:</h5>`;
            
            // Group by source
            const grouped = results.reduce((acc, item) => {
                const source = item.source || 'unknown';
                if (!acc[source]) acc[source] = [];
                acc[source].push(item);
                return acc;
            }, {});
            
            Object.keys(grouped).forEach(source => {
                const sourceLabel = {
                    'html_analysis': 'ğŸ“„ ØªØ­Ù„ÙŠÙ„ Ù…Ù„ÙØ§Øª HTML',
                    'manual': 'âœï¸ Ø¥Ø¯Ø®Ø§Ù„ ÙŠØ¯ÙˆÙŠ',
                    'url_generation': 'ğŸ”— ØªÙˆÙ„ÙŠØ¯ Ù…Ù† Ø§Ù„Ø±ÙˆØ§Ø¨Ø·',
                    'sitemap': 'ğŸ—ºï¸ Ù…Ù† Sitemap.xml',
                    'robots': 'ğŸ¤– Ù…Ù† robots.txt',
                    'github': 'ğŸ™ Ù…Ù† GitHub Pages'
                }[source] || source;
                
                html += `<h6 class="mt-3 text-primary">${sourceLabel} (${grouped[source].length})</h6>`;
                
                grouped[source].forEach(item => {
                    html += `
                    <div class="page-item" data-id="${item.id}">
                        <button class="btn btn-outline-secondary btn-sm edit-btn" onclick="toggleEdit(${item.id})">ØªØ­Ø±ÙŠØ±</button>
                        <div class="page-title editable-content" data-field="title" contenteditable="false">${item.title}</div>
                        <div class="page-url">${item.url}</div>
                        <div class="text-muted editable-content" data-field="description" contenteditable="false">${item.description}</div>
                        <div class="mt-2">
                            <small class="text-info">Ø§Ù„ÙØ¦Ø©: <span class="editable-content" data-field="category" contenteditable="false">${item.category}</span></small>
                        </div>
                        <div class="mt-1">
                            <small class="text-success">Ø§Ù„ÙƒÙ„Ù…Ø§Øª: <span class="editable-content" data-field="tags" contenteditable="false">${item.tags.join(', ')}</span></small>
                        </div>
                    </div>
                    `;
                });
            });
            
            resultsDiv.innerHTML = html;
            
            // Show export buttons
            document.getElementById('exportButtons').style.display = 'flex';
        }
        
        function toggleEdit(itemId) {
            const pageItem = document.querySelector(`[data-id="${itemId}"]`);
            const editableElements = pageItem.querySelectorAll('.editable-content');
            const editBtn = pageItem.querySelector('.edit-btn');
            
            const isEditing = editableElements[0].getAttribute('contenteditable') === 'true';
            
            if (isEditing) {
                // Save changes
                editableElements.forEach(element => {
                    element.setAttribute('contenteditable', 'false');
                    element.style.backgroundColor = '';
                    
                    const field = element.getAttribute('data-field');
                    const value = element.textContent.trim();
                    
                    // Update searchIndex
                    const item = searchIndex.find(item => item.id === itemId);
                    if (item) {
                        if (field === 'tags') {
                            item[field] = value.split(',').map(t => t.trim()).filter(t => t);
                        } else {
                            item[field] = value;
                        }
                    }
                });
                
                editBtn.textContent = 'ØªØ­Ø±ÙŠØ±';
                editBtn.className = 'btn btn-outline-secondary btn-sm edit-btn';
                showNotification('ØªÙ… Ø­ÙØ¸ Ø§Ù„ØªØ¹Ø¯ÙŠÙ„Ø§Øª! âœ…', 'success');
                updateStatistics();
                autoSave();
            } else {
                // Enable editing
                editableElements.forEach(element => {
                    element.setAttribute('contenteditable', 'true');
                    element.style.backgroundColor = '#fff3cd';
                });
                
                editBtn.textContent = 'Ø­ÙØ¸';
                editBtn.className = 'btn btn-success btn-sm edit-btn';
            }
        }
        
        // Enhanced export functions
        function downloadJson() {
            const jsonData = JSON.stringify(searchIndex.map(item => ({
                id: item.id,
                title: item.title,
                description: item.description,
                url: item.url,
                category: item.category,
                tags: item.tags
            })), null, 2);
            
            const blob = new Blob([jsonData], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            
            const a = document.createElement('a');
            a.href = url;
            a.download = 'search-index.json';
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
            
            showNotification('ØªÙ… ØªØ­Ù…ÙŠÙ„ search-index.json Ø¨Ù†Ø¬Ø§Ø­! âœ…', 'success');
        }
        
        function downloadCSV() {
            const headers = ['ID', 'Ø§Ù„Ø¹Ù†ÙˆØ§Ù†', 'Ø§Ù„Ø±Ø§Ø¨Ø·', 'Ø§Ù„ÙˆØµÙ', 'Ø§Ù„ÙØ¦Ø©', 'Ø§Ù„ÙƒÙ„Ù…Ø§Øª Ø§Ù„Ù…ÙØªØ§Ø­ÙŠØ©'];
            const csvContent = [
                headers.join(','),
                ...searchIndex.map(item => [
                    item.id,
                    `"${item.title.replace(/"/g, '""')}"`,
                    `"${item.url}"`,
                    `"${item.description.replace(/"/g, '""')}"`,
                    `"${item.category}"`,
                    `"${item.tags.join(', ').replace(/"/g, '""')}"`
                ].join(','))
            ].join('\n');
            
            // Add BOM for proper Arabic display in Excel
            const blob = new Blob(['\ufeff' + csvContent], { type: 'text/csv;charset=utf-8;' });
            const url = URL.createObjectURL(blob);
            
            const a = document.createElement('a');
            a.href = url;
            a.download = 'search-index.csv';
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
            
            showNotification('ØªÙ… ØªØ­Ù…ÙŠÙ„ search-index.csv Ø¨Ù†Ø¬Ø§Ø­! ğŸ“Š', 'success');
        }
        
        async function downloadZip() {
            const zipProgress = document.getElementById('zipProgress');
            const zipProgressBar = document.getElementById('zipProgressBar');
            const zipProgressText = document.getElementById('zipProgressText');
            
            zipProgress.style.display = 'block';
            zipProgressBar.style.width = '10%';
            zipProgressText.textContent = 'Ø¬Ø§Ø±ÙŠ Ø¥Ù†Ø´Ø§Ø¡ Ù…Ù„Ù ZIP...';
            
            try {
                const zip = new JSZip();
                
                // Add search-index.json
                const jsonData = JSON.stringify(searchIndex.map(item => ({
                    id: item.id,
                    title: item.title,
                    description: item.description,
                    url: item.url,
                    category: item.category,
                    tags: item.tags
                })), null, 2);
                
                zip.file('search-index.json', jsonData);
                zipProgressBar.style.width = '30%';
                zipProgressText.textContent = 'ØªÙ… Ø¥Ø¶Ø§ÙØ© search-index.json...';
                
                // Add HTML files if available
                const htmlFiles = analyzedFiles.filter(file => file.content);
                if (htmlFiles.length > 0) {
                    const htmlFolder = zip.folder('html-files');
                    
                    for (let i = 0; i < htmlFiles.length; i++) {
                        const file = htmlFiles[i];
                        htmlFolder.file(file.filename, file.content);
                        
                        const progress = 30 + (i + 1) / htmlFiles.length * 50;
                        zipProgressBar.style.width = progress + '%';
                        zipProgressText.textContent = `ØªÙ… Ø¥Ø¶Ø§ÙØ© ${file.filename}...`;
                        
                        // Small delay for UI responsiveness
                        await new Promise(resolve => setTimeout(resolve, 50));
                    }
                }
                
                zipProgressBar.style.width = '90%';
                zipProgressText.textContent = 'Ø¬Ø§Ø±ÙŠ Ø¶ØºØ· Ø§Ù„Ù…Ù„ÙØ§Øª...';
                
                // Generate ZIP file
                const content = await zip.generateAsync({type: 'blob'});
                
                zipProgressBar.style.width = '100%';
                zipProgressText.textContent = 'ØªÙ… Ø¥Ù†Ø´Ø§Ø¡ Ø§Ù„Ù…Ù„Ù Ø¨Ù†Ø¬Ø§Ø­!';
                
                // Download ZIP
                const url = URL.createObjectURL(content);
                const a = document.createElement('a');
                a.href = url;
                a.download = 'search-index-package.zip';
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
                
                showNotification('ØªÙ… ØªØ­Ù…ÙŠÙ„ Ø§Ù„Ø­Ø²Ù…Ø© Ø§Ù„ÙƒØ§Ù…Ù„Ø© Ø¨Ù†Ø¬Ø§Ø­! ğŸ“¦', 'success');
                
                setTimeout(() => {
                    zipProgress.style.display = 'none';
                }, 2000);
                
            } catch (error) {
                showNotification('Ø®Ø·Ø£ ÙÙŠ Ø¥Ù†Ø´Ø§Ø¡ Ù…Ù„Ù ZIP: ' + error.message, 'danger');
                zipProgress.style.display = 'none';
            }
        }
        
        function toggleCopyOptions() {
            const copyOptions = document.getElementById('copyOptions');
            copyOptions.style.display = copyOptions.style.display === 'none' ? 'block' : 'none';
        }
        
        function copyToClipboard(type) {
            let content = '';
            
            switch (type) {
                case 'all':
                    content = JSON.stringify(searchIndex.map(item => ({
                        id: item.id,
                        title: item.title,
                        description: item.description,
                        url: item.url,
                        category: item.category,
                        tags: item.tags
                    })), null, 2);
                    break;
                case 'titles':
                    content = searchIndex.map(item => item.title).join('\n');
                    break;
                case 'urls':
                    content = searchIndex.map(item => item.url).join('\n');
                    break;
                case 'descriptions':
                    content = searchIndex.map(item => item.description).join('\n');
                    break;
            }
            
            navigator.clipboard.writeText(content).then(() => {
                const typeLabels = {
                    'all': 'Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„ÙƒØ§Ù…Ù„Ø©',
                    'titles': 'Ø§Ù„Ø¹Ù†Ø§ÙˆÙŠÙ†',
                    'urls': 'Ø§Ù„Ø±ÙˆØ§Ø¨Ø·',
                    'descriptions': 'Ø§Ù„Ø£ÙˆØµØ§Ù'
                };
                showNotification(`ØªÙ… Ù†Ø³Ø® ${typeLabels[type]} Ø¥Ù„Ù‰ Ø§Ù„Ø­Ø§ÙØ¸Ø©! ğŸ“‹`, 'success');
                toggleCopyOptions();
            }).catch(err => {
                console.error('Ø®Ø·Ø£ ÙÙŠ Ø§Ù„Ù†Ø³Ø®:', err);
                // Fallback
                const textArea = document.createElement('textarea');
                textArea.value = content;
                document.body.appendChild(textArea);
                textArea.select();
                document.execCommand('copy');
                document.body.removeChild(textArea);
                showNotification('ØªÙ… Ù†Ø³Ø® Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª Ø¥Ù„Ù‰ Ø§Ù„Ø­Ø§ÙØ¸Ø©! ğŸ“‹', 'success');
                toggleCopyOptions();
            });
        }
        
        // Auto-save when URL input changes
        document.getElementById('urlInput').addEventListener('input', autoSave);
    </script>
</body>
</html>